# 关卡场景迁移指南

## 1. 概述

本文档详细说明如何将现有BattleScene中的硬编码内容（角色生成、地面设置、障碍物配置等）迁移到独立的关卡场景中，实现符合Godot设计哲学的模块化关卡系统。

### 1.1 迁移目标
- 将角色生成逻辑从BattleCharacterManager迁移到关卡场景
- 将地面和环境设置移至关卡配置
- 实现关卡设计师可独立编辑的关卡系统
- 保持现有战斗系统的完整性

### 1.2 迁移原则
- **分离关注点**: BattleScene专注于战斗系统，关卡场景专注于内容
- **数据驱动**: 使用配置文件而非硬编码
- **可复用性**: 关卡模板可以被复制和修改
- **向后兼容**: 迁移过程中保持现有功能正常运行

## 2. 当前系统分析

### 2.1 需要迁移的内容

#### 从BattleCharacterManager中迁移:
```gdscript
# 当前在BattleCharacterManager中的硬编码内容
var party_member_ids = ["1", "2", "3"]  # 友方角色ID列表
var enemy_configs = [
    {"id": "101", "position": Vector2(1000, 1000)},
    {"id": "102", "position": Vector2(1100, 1000)},
    {"id": "103", "position": Vector2(1200, 1000)}
]

# 位置计算逻辑
func _setup_party_member_positions():
    # 硬编码的位置计算
```

#### 从BattleScene中迁移:
```gdscript
# 当前在BattleScene中的关卡加载
func _load_initial_level():
    var level_scene = preload("res://Scenes/Levels/Level_1_序幕.tscn")
    # 硬编码的关卡选择逻辑
```

#### 从其他系统中迁移:
- 地面高度配置
- 障碍物布局
- 特殊地形设置
- 环境光照配置

### 2.2 当前数据流

```
BattleScene._ready()
    ↓
BattleCharacterManager.initialize()
    ↓
硬编码角色列表 → 生成角色节点
    ↓
硬编码位置 → 设置角色位置
    ↓
关卡场景挂载 → 障碍物加载
```

## 3. 目标架构设计

### 3.1 新的数据流

```
BattleScene._ready()
    ↓
加载关卡场景 → LevelConfiguration.gd
    ↓
读取关卡配置 → 角色配置、位置配置
    ↓
BattleCharacterManager.load_from_level_config()
    ↓
动态生成角色 → 战斗开始
```

### 3.2 关卡配置系统

#### LevelConfiguration.gd (关卡配置脚本)
```gdscript
extends Node
class_name LevelConfiguration

# 关卡基础信息
@export var level_name: String = "序幕"
@export var level_id: String = "level_1"
@export var description: String = "游戏开始的序幕关卡"

# 角色配置
@export_group("角色配置")
@export var player_character_ids: Array[String] = ["1", "2", "3"]
@export var enemy_configurations: Array[EnemyConfig] = []

# 环境配置
@export_group("环境配置") 
@export var ground_height: float = 1000.0
@export var gravity_scale: float = 1.0
@export var ambient_light_color: Color = Color.WHITE

# 视觉配置
@export_group("视觉配置")
@export var background_music: AudioStream
@export var ambient_sound: AudioStream
@export var weather_effects: Array[String] = []

# 获取角色生成点
func get_player_spawn_points() -> Array[Vector2]:
    var spawns = []
    var spawn_nodes = get_node_or_null("../GameplayLayers/CharacterSpawns/PlayerSpawns")
    if spawn_nodes:
        for child in spawn_nodes.get_children():
            if child is Marker2D:
                spawns.append(child.global_position)
    return spawns

func get_enemy_spawn_points() -> Array[Vector2]:
    var spawns = []
    var spawn_nodes = get_node_or_null("../GameplayLayers/CharacterSpawns/EnemySpawns")
    if spawn_nodes:
        for child in spawn_nodes.get_children():
            if child is Marker2D:
                spawns.append(child.global_position)
    return spawns
```

#### EnemyConfig.gd (敌人配置资源)
```gdscript
extends Resource
class_name EnemyConfig

@export var enemy_id: String
@export var spawn_index: int = 0  # 对应EnemySpawn节点的索引
@export var level_override: int = -1  # -1表示使用默认等级
@export var custom_ai_behavior: String = ""
@export var special_abilities: Array[String] = []
```

## 4. 迁移步骤

### 4.1 第一阶段：创建关卡配置系统

#### 1. 创建LevelConfiguration脚本
```gdscript
# Scripts/Level/LevelConfiguration.gd
extends Node
class_name LevelConfiguration

@export var level_name: String = ""
@export var player_character_ids: Array[String] = []
@export var enemy_configurations: Array[EnemyConfig] = []

signal level_data_ready(config: LevelConfiguration)

func _ready():
    # 验证配置数据
    if validate_configuration():
        level_data_ready.emit(self)
    else:
        printerr("关卡配置验证失败: " + level_name)

func validate_configuration() -> bool:
    if player_character_ids.is_empty():
        printerr("玩家角色列表不能为空")
        return false
    return true

func get_player_spawn_points() -> Array[Vector2]:
    # 实现代码...
    pass

func get_enemy_spawn_points() -> Array[Vector2]:
    # 实现代码...
    pass
```

#### 2. 创建EnemyConfig资源
```gdscript
# Scripts/Level/EnemyConfig.gd
extends Resource
class_name EnemyConfig

@export var enemy_id: String
@export var spawn_index: int = 0
@export var level_override: int = -1
```

### 4.2 第二阶段：修改LEVEL_1_序幕.tscn

#### 1. 重构场景结构
按照多层背景系统文档中的关卡场景结构重新组织节点：

```
LevelRoot (Node2D)
├── BackgroundLayers (CanvasLayer)
├── GameplayLayers (Node2D)
│   ├── GroundLayer (Node2D)
│   ├── ObstacleLayer (Node2D)
│   │   └── Obstacles (Node2D)
│   │       └── [移动现有的Obstacle节点到这里]
│   ├── CharacterSpawns (Node2D)
│   │   ├── PlayerSpawns (Node2D)
│   │   │   ├── PlayerSpawn1 (Marker2D) [position: (600, 1000)]
│   │   │   ├── PlayerSpawn2 (Marker2D) [position: (700, 1000)]
│   │   │   └── PlayerSpawn3 (Marker2D) [position: (800, 1000)]
│   │   └── EnemySpawns (Node2D)
│   │       ├── EnemySpawn1 (Marker2D) [position: (1000, 1000)]
│   │       ├── EnemySpawn2 (Marker2D) [position: (1100, 1000)]
│   │       └── EnemySpawn3 (Marker2D) [position: (1200, 1000)]
├── ForegroundLayers (CanvasLayer)
└── LevelConfiguration (Node)
    └── LevelData (挂载LevelConfiguration.gd脚本)
```

#### 2. 配置LevelConfiguration节点
在Godot编辑器中设置LevelConfiguration节点的导出属性：
- **level_name**: "序幕"
- **level_id**: "level_1"
- **player_character_ids**: ["1", "2", "3"]
- **enemy_configurations**: 
  - EnemyConfig 1: enemy_id="101", spawn_index=0
  - EnemyConfig 2: enemy_id="102", spawn_index=1  
  - EnemyConfig 3: enemy_id="103", spawn_index=2

### 4.3 第三阶段：修改BattleCharacterManager

#### 1. 添加关卡配置支持
```gdscript
# 在BattleCharacterManager中添加
var current_level_config: LevelConfiguration
var level_spawned_characters: Dictionary = {}

func load_from_level_config(level_config: LevelConfiguration):
    current_level_config = level_config
    
    print("🎮 [角色管理器] 从关卡配置加载角色")
    print("关卡名称: " + level_config.level_name)
    
    # 清除现有角色
    clear_existing_characters()
    
    # 加载玩家角色
    await load_player_characters()
    
    # 加载敌人角色
    await load_enemy_characters()
    
    print("✅ [角色管理器] 关卡角色加载完成")

func load_player_characters():
    var spawn_points = current_level_config.get_player_spawn_points()
    var character_ids = current_level_config.player_character_ids
    
    for i in range(character_ids.size()):
        var character_id = character_ids[i]
        var spawn_position = spawn_points[i] if i < spawn_points.size() else Vector2.ZERO
        
        print("🎯 [角色管理器] 生成玩家角色: ID=%s, 位置=%s" % [character_id, spawn_position])
        
        # 使用现有的角色生成逻辑，但使用配置的位置
        var character_node = await create_character_node(character_id, true)
        if character_node:
            character_node.global_position = spawn_position
            level_spawned_characters[character_id] = character_node

func load_enemy_characters():
    var spawn_points = current_level_config.get_enemy_spawn_points()
    
    for enemy_config in current_level_config.enemy_configurations:
        var spawn_position = spawn_points[enemy_config.spawn_index] if enemy_config.spawn_index < spawn_points.size() else Vector2.ZERO
        
        print("🎯 [角色管理器] 生成敌人角色: ID=%s, 位置=%s" % [enemy_config.enemy_id, spawn_position])
        
        var character_node = await create_character_node(enemy_config.enemy_id, false)
        if character_node:
            character_node.global_position = spawn_position
            level_spawned_characters[enemy_config.enemy_id] = character_node

func clear_existing_characters():
    # 清除现有的硬编码角色
    for child in party_member_nodes.values():
        if child:
            child.queue_free()
    for child in enemy_nodes.values():
        if child:
            child.queue_free()
            
    party_member_nodes.clear()
    enemy_nodes.clear()
    level_spawned_characters.clear()
```

#### 2. 重构现有的角色生成方法
```gdscript
# 将现有的generate_party_members()等方法标记为弃用
# 创建新的通用角色生成方法

func create_character_node(character_id: String, is_player: bool) -> Node:
    # 重用现有的角色创建逻辑，但移除硬编码部分
    print("🔧 [角色管理器] 创建角色节点: ID=%s, 是否玩家=%s" % [character_id, is_player])
    
    # 使用现有的角色创建逻辑...
    var character_scene = preload("res://Prefabs/BattleCharacter.tscn")
    var character_node = character_scene.instantiate()
    
    # 设置角色数据...
    var character_data = await load_character_data(character_id)
    character_node.set_character_data(character_data)
    
    # 添加到相应的容器
    if is_player:
        add_child(character_node)
        party_member_nodes[character_id] = character_node
    else:
        add_child(character_node)
        enemy_nodes[character_id] = character_node
    
    return character_node
```

### 4.4 第四阶段：修改BattleScene

#### 1. 修改关卡加载逻辑
```gdscript
# 在BattleScene中修改
func _ready():
    # ... 现有初始化代码 ...
    
    # 加载关卡场景
    await load_dynamic_level()

func load_dynamic_level(level_path: String = "res://Scenes/Levels/Level_1_序幕.tscn"):
    print("🎮 [战斗场景] 加载动态关卡: " + level_path)
    
    var level_scene = load(level_path)
    if not level_scene:
        printerr("❌ [战斗场景] 无法加载关卡场景: " + level_path)
        return
    
    var level_instance = level_scene.instantiate()
    var dynamics_level = get_node("DynamicsLevel")
    dynamics_level.add_child(level_instance)
    
    # 查找并连接关卡配置
    var level_config = level_instance.get_node_or_null("LevelConfiguration/LevelData")
    if level_config and level_config is LevelConfiguration:
        level_config.level_data_ready.connect(_on_level_data_ready)
        print("✅ [战斗场景] 关卡配置连接成功")
    else:
        printerr("⚠️ [战斗场景] 未找到关卡配置节点")

func _on_level_data_ready(config: LevelConfiguration):
    print("🎯 [战斗场景] 关卡数据准备就绪: " + config.level_name)
    
    # 通知角色管理器加载角色
    if character_manager:
        await character_manager.load_from_level_config(config)
    
    # 其他系统初始化...
    await initialize_other_systems_with_level(config)
    
    print("✅ [战斗场景] 关卡初始化完成")

func initialize_other_systems_with_level(config: LevelConfiguration):
    # 初始化其他需要关卡配置的系统
    if battle_manager:
        battle_manager.set_level_configuration(config)
    
    # 设置环境参数
    setup_level_environment(config)

func setup_level_environment(config: LevelConfiguration):
    # 设置重力、光照等环境参数
    if config.gravity_scale != 1.0:
        PhysicsServer2D.area_set_param(
            get_viewport().find_world_2d().space,
            PhysicsServer2D.AREA_PARAM_GRAVITY_SCALE,
            config.gravity_scale
        )
```

### 4.5 第五阶段：数据迁移

#### 1. 迁移现有角色配置
将BattleCharacterManager中的硬编码角色列表迁移到关卡配置：

```gdscript
# 从这个硬编码配置:
var party_member_ids = ["1", "2", "3"]
var enemy_configs = [
    {"id": "101", "position": Vector2(1000, 1000)},
    {"id": "102", "position": Vector2(1100, 1000)}, 
    {"id": "103", "position": Vector2(1200, 1000)}
]

# 迁移到关卡场景的LevelConfiguration配置和Marker2D位置
```

#### 2. 创建关卡模板
```gdscript
# Scripts/Level/LevelTemplate.gd
# 用于快速创建新关卡的模板脚本

extends EditorScript

func _run():
    create_level_template("NewLevel")

func create_level_template(level_name: String):
    var level_scene = PackedScene.new()
    
    # 创建基础节点结构...
    var root = Node2D.new()
    root.name = "LevelRoot"
    
    # 添加各层级节点...
    setup_background_layers(root)
    setup_gameplay_layers(root)
    setup_foreground_layers(root)
    setup_level_configuration(root, level_name)
    
    # 保存场景
    level_scene.pack(root)
    ResourceSaver.save(level_scene, "res://Scenes/Levels/" + level_name + ".tscn")
```

## 5. 测试和验证

### 5.1 迁移验证清单

- [ ] 关卡场景可以独立打开和编辑
- [ ] 角色生成点位置正确
- [ ] 角色配置可以在编辑器中修改
- [ ] 战斗系统仍然正常工作
- [ ] 障碍物系统保持功能
- [ ] 背景系统正常显示

### 5.2 测试步骤

1. **独立关卡测试**
   ```gdscript
   # 创建测试脚本验证关卡可独立运行
   func test_level_standalone():
       var level = preload("res://Scenes/Levels/Level_1_序幕.tscn").instantiate()
       add_child(level)
       
       var config = level.get_node("LevelConfiguration/LevelData")
       assert(config != null, "关卡配置节点存在")
       assert(config.player_character_ids.size() > 0, "玩家角色配置非空")
   ```

2. **角色生成测试**
   ```gdscript
   func test_character_spawning():
       # 验证角色是否在正确位置生成
       # 验证角色数据是否正确加载
   ```

3. **战斗系统集成测试**
   ```gdscript
   func test_battle_integration():
       # 验证战斗系统是否能正确识别关卡生成的角色
       # 验证技能系统、移动系统等是否正常
   ```

## 6. 进阶功能

### 6.1 关卡编辑器工具

```gdscript
# Scripts/Tools/LevelEditor.gd
@tool
extends EditorPlugin

func handles(object):
    return object is LevelConfiguration

func edit(object):
    # 创建自定义的关卡编辑界面
    var editor = preload("res://Tools/LevelConfigEditor.tscn").instantiate()
    editor.edit_configuration(object)
    return editor
```

### 6.2 关卡验证系统

```gdscript
# Scripts/Level/LevelValidator.gd
extends RefCounted
class_name LevelValidator

static func validate_level(level_config: LevelConfiguration) -> Array[String]:
    var errors = []
    
    # 验证角色配置
    if level_config.player_character_ids.is_empty():
        errors.append("玩家角色列表不能为空")
    
    # 验证生成点数量
    var player_spawns = level_config.get_player_spawn_points()
    if player_spawns.size() < level_config.player_character_ids.size():
        errors.append("玩家生成点数量不足")
    
    return errors
```

### 6.3 关卡序列化

```gdscript
# Scripts/Level/LevelSerializer.gd
# 支持将关卡配置序列化为JSON，便于版本控制和编辑

func export_level_to_json(level_config: LevelConfiguration) -> String:
    var data = {
        "level_name": level_config.level_name,
        "player_characters": level_config.player_character_ids,
        "enemy_configs": serialize_enemy_configs(level_config.enemy_configurations)
    }
    return JSON.stringify(data)

func import_level_from_json(json_string: String) -> LevelConfiguration:
    # 从JSON恢复关卡配置
    pass
```

## 7. 迁移时间表

### 阶段一 (1-2天)
- 创建LevelConfiguration脚本
- 创建EnemyConfig资源
- 设置基础关卡场景结构

### 阶段二 (2-3天)  
- 修改LEVEL_1_序幕.tscn场景结构
- 添加角色生成点Marker2D节点
- 配置关卡参数

### 阶段三 (3-4天)
- 修改BattleCharacterManager支持关卡配置
- 重构角色生成逻辑
- 测试角色生成功能

### 阶段四 (2-3天)
- 修改BattleScene关卡加载逻辑
- 集成测试整个系统
- 修复发现的问题

### 阶段五 (1-2天)
- 创建关卡编辑工具
- 编写文档和测试用例
- 代码清理和优化

## 8. 总结

通过这个迁移指南，我们将实现：

1. **关卡设计师友好**: 可以在Godot编辑器中直接编辑关卡内容
2. **数据驱动**: 角色配置、位置等通过配置文件而非硬编码
3. **模块化**: 关卡与战斗系统分离，便于维护和扩展
4. **可复用**: 关卡模板可以快速创建新关卡

这个架构将大大提升开发效率，使得关卡内容的制作更加灵活和直观。 