# æˆ˜æ–—ç®¡ç†å™¨ - BattleSceneåœºæ™¯èŠ‚ç‚¹
# èŒè´£ï¼šæˆ˜æ–—æµç¨‹æ§åˆ¶ã€å›åˆç®¡ç†ã€è§’è‰²è¡ŒåŠ¨åè°ƒ
# è®¾è®¡ç†å¿µï¼šç¬¦åˆGodotåœºæ™¯æ ‘æ¶æ„ï¼Œç”Ÿå‘½å‘¨æœŸä¸BattleSceneç»‘å®š
extends Node

#region ä¿¡å·å®šä¹‰
signal battle_started()
signal battle_ended(result: Dictionary)
signal turn_started(turn_number: int)
signal turn_ended(turn_number: int)
signal character_action_completed(character: GameCharacter, action_result: Dictionary)
#endregion

#region æˆ˜æ–—çŠ¶æ€
var is_battle_active: bool = false
var current_turn: int = 0
var turn_queue: Array[GameCharacter] = []
var battle_participants: Array[GameCharacter] = []
var battle_start_time: float = 0.0
#endregion

#region åœ°å½¢ç®¡ç†ï¼ˆä¿ç•™åŸæœ‰åŠŸèƒ½ï¼‰
var terrain_struct = TerrainStruct.new(Vector2(0,0), _init_terrain_arr(), [],[],[],[])
var _battle_terrain_arr = _init_terrain_arr()
#endregion

#region åœºæ™¯ç»„ä»¶å¼•ç”¨
@onready var battle_scene: Node2D = get_parent()
@onready var action_system: Node = null
@onready var players_container: Node = null
#endregion

func _ready() -> void:
	print("âš”ï¸ [BattleManager] æˆ˜æ–—ç®¡ç†å™¨åˆå§‹åŒ– - åœºæ™¯èŠ‚ç‚¹æ¨¡å¼")
	
	# è·å–åœºæ™¯ä¸­çš„å…¶ä»–ç»„ä»¶å¼•ç”¨
	_setup_component_references()
	
	# è¿æ¥å¿…è¦çš„ä¿¡å·
	_connect_scene_signals()

#region ç»„ä»¶åˆå§‹åŒ–
func _setup_component_references() -> void:
	# è·å–BattleSceneä¸­çš„å…¶ä»–ç»„ä»¶
	if battle_scene:
		action_system = battle_scene.get_node_or_null("ActionSystem")
		players_container = battle_scene.get_node_or_null("Players")
	
	if action_system:
		print("âœ… [BattleManager] æ‰¾åˆ°ActionSystemç»„ä»¶")
	if players_container:
		print("âœ… [BattleManager] æ‰¾åˆ°Playerså®¹å™¨")

func _connect_scene_signals() -> void:
	# è¿æ¥åœºæ™¯ä¸­çš„ç›¸å…³ä¿¡å·
	if action_system and action_system.has_signal("action_selected"):
		action_system.action_selected.connect(_on_action_selected)
#endregion

#region æˆ˜æ–—æµç¨‹æ§åˆ¶
func start_battle(participants: Array[GameCharacter] = []) -> void:
	if is_battle_active:
		print("âš ï¸ [BattleManager] æˆ˜æ–—å·²åœ¨è¿›è¡Œä¸­")
		return
	
	print("ğŸš€ [BattleManager] å¼€å§‹æˆ˜æ–—")
	
	# åˆå§‹åŒ–æˆ˜æ–—çŠ¶æ€
	is_battle_active = true
	current_turn = 0
	battle_start_time = Time.get_unix_time_from_system()
	
	# è®¾ç½®å‚æˆ˜è§’è‰²
	if participants.is_empty():
		# å¦‚æœæ²¡æœ‰ä¼ å…¥å‚æˆ˜è€…ï¼Œä»åœºæ™¯ä¸­è·å–
		battle_participants = _get_scene_characters()
	else:
		battle_participants = participants
	
	print("ğŸ“‹ [BattleManager] å‚æˆ˜è§’è‰²æ•°é‡: %d" % battle_participants.size())
	
	# å‘å‡ºæˆ˜æ–—å¼€å§‹ä¿¡å·
	battle_started.emit()
	
	# å¼€å§‹ç¬¬ä¸€å›åˆ
	start_next_turn()

func end_battle(winner_side: String = "", battle_result: Dictionary = {}) -> void:
	if not is_battle_active:
		return
	
	print("ğŸ [BattleManager] æˆ˜æ–—ç»“æŸ")
	
	# è®¡ç®—æˆ˜æ–—ç»“æœ
	var final_result = _calculate_battle_result(winner_side, battle_result)
	
	# æ¸…ç†æˆ˜æ–—çŠ¶æ€
	is_battle_active = false
	turn_queue.clear()
	
	# å‘å‡ºæˆ˜æ–—ç»“æŸä¿¡å·
	battle_ended.emit(final_result)
	
	print("ğŸ“Š [BattleManager] æˆ˜æ–—æ€»ç”¨æ—¶: %.1fç§’, æ€»å›åˆæ•°: %d" % [
		Time.get_unix_time_from_system() - battle_start_time, 
		current_turn
	])

func start_next_turn() -> void:
	if not is_battle_active:
		return
	
	current_turn += 1
	print("ğŸ¯ [BattleManager] ç¬¬ %d å›åˆå¼€å§‹" % current_turn)
	
	# è®¡ç®—å›åˆè¡ŒåŠ¨é¡ºåº
	turn_queue = _calculate_turn_order()
	
	# å‘å‡ºå›åˆå¼€å§‹ä¿¡å·
	turn_started.emit(current_turn)
	
	# å¼€å§‹å¤„ç†è§’è‰²è¡ŒåŠ¨
	_process_turn_actions()

func _process_turn_actions() -> void:
	print("ğŸ® [BattleManager] å¤„ç†å›åˆè¡ŒåŠ¨ï¼Œé˜Ÿåˆ—é•¿åº¦: %d" % turn_queue.size())
	
	# é€ä¸ªå¤„ç†è§’è‰²è¡ŒåŠ¨
	for character in turn_queue:
		if not character.is_alive():
			continue
		
		print("ğŸ‘¤ [BattleManager] è½®åˆ° %s è¡ŒåŠ¨" % character.name)
		
		# ç­‰å¾…è§’è‰²è¡ŒåŠ¨å®Œæˆ
		await _handle_character_action(character)
		
		# æ£€æŸ¥æˆ˜æ–—æ˜¯å¦ç»“æŸ
		if _check_battle_end_condition():
			var winner = _determine_winner()
			end_battle(winner)
			return
	
	# å›åˆç»“æŸå¤„ç†
	_end_current_turn()

func _end_current_turn() -> void:
	print("âœ… [BattleManager] ç¬¬ %d å›åˆç»“æŸ" % current_turn)
	
	# å¤„ç†å›åˆç»“æŸæ•ˆæœï¼ˆçŠ¶æ€æ•ˆæœã€æŠ€èƒ½å†·å´ç­‰ï¼‰
	_process_turn_end_effects()
	
	# å‘å‡ºå›åˆç»“æŸä¿¡å·
	turn_ended.emit(current_turn)
	
	# å¼€å§‹ä¸‹ä¸€å›åˆ
	await get_tree().process_frame  # ç­‰å¾…ä¸€å¸§ï¼Œé¿å…è¿‡åº¦é€’å½’
	start_next_turn()
#endregion

#region è§’è‰²è¡ŒåŠ¨å¤„ç†
func _handle_character_action(character: GameCharacter) -> void:
	print("ğŸ¯ [BattleManager] å¤„ç† %s çš„è¡ŒåŠ¨" % character.name)
	
	# æ ¹æ®è§’è‰²ç±»å‹å¤„ç†è¡ŒåŠ¨
	if character.is_player_controlled():
		await _handle_player_action(character)
	else:
		await _handle_ai_action(character)

func _handle_player_action(character: GameCharacter) -> void:
	print("ğŸ® [BattleManager] ç­‰å¾…ç©å®¶æ“ä½œ: %s" % character.name)
	
	# é€šçŸ¥ActionSystemå½“å‰è¡ŒåŠ¨è§’è‰²
	if action_system and action_system.has_method("set_active_character"):
		action_system.set_active_character(character)
	
	# ç­‰å¾…ç©å®¶é€‰æ‹©è¡ŒåŠ¨
	# è¿™é‡Œä¼šç­‰å¾…action_selectedä¿¡å·
	await character_action_completed

func _handle_ai_action(character: GameCharacter) -> void:
	print("ğŸ¤– [BattleManager] AIè§’è‰²è‡ªåŠ¨è¡ŒåŠ¨: %s" % character.name)
	
	# ç®€å•AIé€»è¾‘ï¼šéšæœºé€‰æ‹©ä¸€ä¸ªè¡ŒåŠ¨
	var actions = ["attack", "skill", "defend"]
	var chosen_action = actions[randi() % actions.size()]
	
	var action_result = {
		"type": chosen_action,
		"character": character,
		"success": true,
		"message": "%s ä½¿ç”¨äº† %s" % [character.name, chosen_action]
	}
	
	# æ¨¡æ‹ŸAIè¡ŒåŠ¨æ—¶é—´
	await get_tree().create_timer(1.0).timeout
	
	print("âœ… [BattleManager] AIè¡ŒåŠ¨å®Œæˆ: %s" % action_result.message)
	character_action_completed.emit(character, action_result)

func _on_action_selected(character: GameCharacter, action: Dictionary) -> void:
	print("ğŸ“ [BattleManager] æ”¶åˆ°è¡ŒåŠ¨é€‰æ‹©: %s -> %s" % [character.name, action.get("type", "unknown")])
	
	# æ‰§è¡Œè¡ŒåŠ¨ï¼ˆç­‰å¾…åç¨‹å®Œæˆï¼‰
	var action_result = await _execute_action(character, action)
	
	# å‘å‡ºè¡ŒåŠ¨å®Œæˆä¿¡å·
	character_action_completed.emit(character, action_result)

func _execute_action(character: GameCharacter, action: Dictionary) -> Dictionary:
	print("âš”ï¸ [BattleManager] æ‰§è¡Œè¡ŒåŠ¨: %s" % action.get("type", "unknown"))
	
	# è¿™é‡Œå¯ä»¥æ ¹æ®å…·ä½“è¡ŒåŠ¨ç±»å‹æ‰§è¡Œä¸åŒé€»è¾‘
	var result = {
		"type": action.get("type", "unknown"),
		"character": character,
		"success": true,
		"message": "%s æ‰§è¡Œäº† %s" % [character.name, action.get("type", "è¡ŒåŠ¨")]
	}
	
	# æ¨¡æ‹Ÿè¡ŒåŠ¨æ‰§è¡Œæ—¶é—´
	await get_tree().create_timer(0.5).timeout
	
	return result
#endregion

#region æˆ˜æ–—é€»è¾‘è¾…åŠ©æ–¹æ³•
func _calculate_turn_order() -> Array[GameCharacter]:
	# æŒ‰é€Ÿåº¦å€¼æ’åºå†³å®šè¡ŒåŠ¨é¡ºåº
	var sorted_characters = battle_participants.filter(func(c): return c.is_alive())
	sorted_characters.sort_custom(func(a, b): return a.speed > b.speed)
	
	var names = []
	for char in sorted_characters:
		names.append(char.name)
	print("ğŸ“‹ [BattleManager] è¡ŒåŠ¨é¡ºåº: %s" % str(names))
	
	return sorted_characters

func _get_scene_characters() -> Array[GameCharacter]:
	var characters: Array[GameCharacter] = []
	
	if players_container:
		for child in players_container.get_children():
			if child.is_in_group("party_members"):
				var data_node = child.get_node_or_null("Data")
				if data_node and data_node.has_method("get_character"):
					characters.append(data_node.get_character())
	
	return characters

func _check_battle_end_condition() -> bool:
	# ç®€å•çš„èƒœè´Ÿåˆ¤å®šï¼šæ£€æŸ¥æ˜¯å¦æœ‰é˜µè¥å…¨ç­
	var player_alive = false
	var enemy_alive = false
	
	for character in battle_participants:
		if character.is_alive():
			if character.is_player_controlled():
				player_alive = true
			else:
				enemy_alive = true
	
	return not (player_alive and enemy_alive)

func _determine_winner() -> String:
	var player_alive = false
	var enemy_alive = false
	
	for character in battle_participants:
		if character.is_alive():
			if character.is_player_controlled():
				player_alive = true
			else:
				enemy_alive = true
	
	if player_alive:
		return "player"
	elif enemy_alive:
		return "enemy"
	else:
		return "draw"

func _calculate_battle_result(winner: String, additional_data: Dictionary = {}) -> Dictionary:
	var result = {
		"winner": winner,
		"total_turns": current_turn,
		"duration_seconds": Time.get_unix_time_from_system() - battle_start_time,
		"participants": battle_participants.size(),
		"timestamp": Time.get_unix_time_from_system()
	}
	
	# åˆå¹¶é¢å¤–æ•°æ®
	for key in additional_data:
		result[key] = additional_data[key]
	
	return result

func _process_turn_end_effects() -> void:
	# å¤„ç†å›åˆç»“æŸæ—¶çš„å„ç§æ•ˆæœ
	for character in battle_participants:
		if character.is_alive():
			# è¿™é‡Œå¯ä»¥å¤„ç†çŠ¶æ€æ•ˆæœã€æŠ€èƒ½å†·å´ç­‰
			pass
#endregion

#region åœ°å½¢ç®¡ç†ï¼ˆä¿ç•™åŸæœ‰åŠŸèƒ½ï¼‰
func _init_terrain_arr() -> Array:
	return [
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	]

func _get_battle_terrain_arr() -> Array:
	return [
		[0, 0, 1, 1, 2, 2, 0, 0, 1, 1],
		[0, 0, 1, 1, 2, 2, 0, 0, 1, 1],
		[0, 0, 1, 1, 2, 2, 0, 0, 1, 1]
	]

func _get_origin_point() -> Vector2:
	return Vector2(3,1)

func refresh_terrain_struct() -> void:
	var origin_point = _get_origin_point()
	var battle_terrain_arr = _get_battle_terrain_arr()
	terrain_struct.set_struct(origin_point, battle_terrain_arr,[],[],[],[])

func get_terrain_grid() -> Array:
	return terrain_struct._battle_field
#endregion

#region å…¬å…±æ¥å£æ–¹æ³•
# æä¾›ç»™å…¶ä»–ç»„ä»¶è°ƒç”¨çš„æ–¹æ³•
func get_current_turn() -> int:
	return current_turn

func is_battle_in_progress() -> bool:
	return is_battle_active

func get_active_character() -> GameCharacter:
	if turn_queue.size() > 0:
		return turn_queue[0]
	return null

func get_battle_participants() -> Array[GameCharacter]:
	return battle_participants.duplicate()

# é¢„ç•™çš„è½»é‡çº§å…¨å±€æ¥å£ï¼ˆæœªæ¥æ‰©å±•ç”¨ï¼‰
func get_battle_status() -> Dictionary:
	return {
		"is_active": is_battle_active,
		"current_turn": current_turn,
		"participants_count": battle_participants.size(),
		"active_character": get_active_character().name if get_active_character() else ""
	}
#endregion
