# 战斗管理器 - BattleScene场景节点
# 职责：战斗流程控制、回合管理、角色行动协调
# 设计理念：符合Godot场景树架构，生命周期与BattleScene绑定
extends Node

#region 信号定义
signal battle_started()
signal battle_ended(result: Dictionary)
signal turn_started(turn_number: int)
signal turn_ended(turn_number: int)
signal character_action_completed(character: GameCharacter, action_result: Dictionary)
#endregion

#region 战斗状态
var is_battle_active: bool = false
var current_turn: int = 0
var turn_queue: Array[GameCharacter] = []
var battle_participants: Array[GameCharacter] = []
var battle_start_time: float = 0.0
#endregion

#region 地形管理（保留原有功能）
var terrain_struct = TerrainStruct.new(Vector2(0,0), _init_terrain_arr(), [],[],[],[])
var _battle_terrain_arr = _init_terrain_arr()
#endregion

#region 场景组件引用
@onready var battle_scene: Node2D = get_parent()
@onready var action_system: Node = null
@onready var players_container: Node = null
#endregion

func _ready() -> void:
	print("⚔️ [BattleManager] 战斗管理器初始化 - 场景节点模式")
	
	# 获取场景中的其他组件引用
	_setup_component_references()
	
	# 连接必要的信号
	_connect_scene_signals()

#region 组件初始化
func _setup_component_references() -> void:
	# 获取BattleScene中的其他组件
	if battle_scene:
		action_system = battle_scene.get_node_or_null("ActionSystem")
		players_container = battle_scene.get_node_or_null("Players")
	
	if action_system:
		print("✅ [BattleManager] 找到ActionSystem组件")
	if players_container:
		print("✅ [BattleManager] 找到Players容器")

func _connect_scene_signals() -> void:
	# 连接场景中的相关信号
	if action_system and action_system.has_signal("action_selected"):
		action_system.action_selected.connect(_on_action_selected)
#endregion

#region 战斗流程控制
func start_battle(participants: Array[GameCharacter] = []) -> void:
	if is_battle_active:
		print("⚠️ [BattleManager] 战斗已在进行中")
		return
	
	print("🚀 [BattleManager] 开始战斗")
	
	# 初始化战斗状态
	is_battle_active = true
	current_turn = 0
	battle_start_time = Time.get_unix_time_from_system()
	
	# 设置参战角色
	if participants.is_empty():
		# 如果没有传入参战者，从场景中获取
		battle_participants = _get_scene_characters()
	else:
		battle_participants = participants
	
	print("📋 [BattleManager] 参战角色数量: %d" % battle_participants.size())
	
	# 发出战斗开始信号
	battle_started.emit()
	
	# 开始第一回合
	start_next_turn()

func end_battle(winner_side: String = "", battle_result: Dictionary = {}) -> void:
	if not is_battle_active:
		return
	
	print("🏁 [BattleManager] 战斗结束")
	
	# 计算战斗结果
	var final_result = _calculate_battle_result(winner_side, battle_result)
	
	# 清理战斗状态
	is_battle_active = false
	turn_queue.clear()
	
	# 发出战斗结束信号
	battle_ended.emit(final_result)
	
	print("📊 [BattleManager] 战斗总用时: %.1f秒, 总回合数: %d" % [
		Time.get_unix_time_from_system() - battle_start_time, 
		current_turn
	])

func start_next_turn() -> void:
	if not is_battle_active:
		return
	
	current_turn += 1
	print("🎯 [BattleManager] 第 %d 回合开始" % current_turn)
	
	# 计算回合行动顺序
	turn_queue = _calculate_turn_order()
	
	# 发出回合开始信号
	turn_started.emit(current_turn)
	
	# 开始处理角色行动
	_process_turn_actions()

func _process_turn_actions() -> void:
	print("🎮 [BattleManager] 处理回合行动，队列长度: %d" % turn_queue.size())
	
	# 逐个处理角色行动
	for character in turn_queue:
		if not character.is_alive():
			continue
		
		print("👤 [BattleManager] 轮到 %s 行动" % character.name)
		
		# 等待角色行动完成
		await _handle_character_action(character)
		
		# 检查战斗是否结束
		if _check_battle_end_condition():
			var winner = _determine_winner()
			end_battle(winner)
			return
	
	# 回合结束处理
	_end_current_turn()

func _end_current_turn() -> void:
	print("✅ [BattleManager] 第 %d 回合结束" % current_turn)
	
	# 处理回合结束效果（状态效果、技能冷却等）
	_process_turn_end_effects()
	
	# 发出回合结束信号
	turn_ended.emit(current_turn)
	
	# 开始下一回合
	await get_tree().process_frame  # 等待一帧，避免过度递归
	start_next_turn()
#endregion

#region 角色行动处理
func _handle_character_action(character: GameCharacter) -> void:
	print("🎯 [BattleManager] 处理 %s 的行动" % character.name)
	
	# 根据角色类型处理行动
	if character.is_player_controlled():
		await _handle_player_action(character)
	else:
		await _handle_ai_action(character)

func _handle_player_action(character: GameCharacter) -> void:
	print("🎮 [BattleManager] 等待玩家操作: %s" % character.name)
	
	# 通知ActionSystem当前行动角色
	if action_system and action_system.has_method("set_active_character"):
		action_system.set_active_character(character)
	
	# 等待玩家选择行动
	# 这里会等待action_selected信号
	await character_action_completed

func _handle_ai_action(character: GameCharacter) -> void:
	print("🤖 [BattleManager] AI角色自动行动: %s" % character.name)
	
	# 简单AI逻辑：随机选择一个行动
	var actions = ["attack", "skill", "defend"]
	var chosen_action = actions[randi() % actions.size()]
	
	var action_result = {
		"type": chosen_action,
		"character": character,
		"success": true,
		"message": "%s 使用了 %s" % [character.name, chosen_action]
	}
	
	# 模拟AI行动时间
	await get_tree().create_timer(1.0).timeout
	
	print("✅ [BattleManager] AI行动完成: %s" % action_result.message)
	character_action_completed.emit(character, action_result)

func _on_action_selected(character: GameCharacter, action: Dictionary) -> void:
	print("📝 [BattleManager] 收到行动选择: %s -> %s" % [character.name, action.get("type", "unknown")])
	
	# 执行行动（等待协程完成）
	var action_result = await _execute_action(character, action)
	
	# 发出行动完成信号
	character_action_completed.emit(character, action_result)

func _execute_action(character: GameCharacter, action: Dictionary) -> Dictionary:
	print("⚔️ [BattleManager] 执行行动: %s" % action.get("type", "unknown"))
	
	# 这里可以根据具体行动类型执行不同逻辑
	var result = {
		"type": action.get("type", "unknown"),
		"character": character,
		"success": true,
		"message": "%s 执行了 %s" % [character.name, action.get("type", "行动")]
	}
	
	# 模拟行动执行时间
	await get_tree().create_timer(0.5).timeout
	
	return result
#endregion

#region 战斗逻辑辅助方法
func _calculate_turn_order() -> Array[GameCharacter]:
	# 按速度值排序决定行动顺序
	var sorted_characters = battle_participants.filter(func(c): return c.is_alive())
	sorted_characters.sort_custom(func(a, b): return a.speed > b.speed)
	
	var names = []
	for char in sorted_characters:
		names.append(char.name)
	print("📋 [BattleManager] 行动顺序: %s" % str(names))
	
	return sorted_characters

func _get_scene_characters() -> Array[GameCharacter]:
	var characters: Array[GameCharacter] = []
	
	if players_container:
		for child in players_container.get_children():
			if child.is_in_group("party_members"):
				var data_node = child.get_node_or_null("Data")
				if data_node and data_node.has_method("get_character"):
					characters.append(data_node.get_character())
	
	return characters

func _check_battle_end_condition() -> bool:
	# 简单的胜负判定：检查是否有阵营全灭
	var player_alive = false
	var enemy_alive = false
	
	for character in battle_participants:
		if character.is_alive():
			if character.is_player_controlled():
				player_alive = true
			else:
				enemy_alive = true
	
	return not (player_alive and enemy_alive)

func _determine_winner() -> String:
	var player_alive = false
	var enemy_alive = false
	
	for character in battle_participants:
		if character.is_alive():
			if character.is_player_controlled():
				player_alive = true
			else:
				enemy_alive = true
	
	if player_alive:
		return "player"
	elif enemy_alive:
		return "enemy"
	else:
		return "draw"

func _calculate_battle_result(winner: String, additional_data: Dictionary = {}) -> Dictionary:
	var result = {
		"winner": winner,
		"total_turns": current_turn,
		"duration_seconds": Time.get_unix_time_from_system() - battle_start_time,
		"participants": battle_participants.size(),
		"timestamp": Time.get_unix_time_from_system()
	}
	
	# 合并额外数据
	for key in additional_data:
		result[key] = additional_data[key]
	
	return result

func _process_turn_end_effects() -> void:
	# 处理回合结束时的各种效果
	for character in battle_participants:
		if character.is_alive():
			# 这里可以处理状态效果、技能冷却等
			pass
#endregion

#region 地形管理（保留原有功能）
func _init_terrain_arr() -> Array:
	return [
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	]

func _get_battle_terrain_arr() -> Array:
	return [
		[0, 0, 1, 1, 2, 2, 0, 0, 1, 1],
		[0, 0, 1, 1, 2, 2, 0, 0, 1, 1],
		[0, 0, 1, 1, 2, 2, 0, 0, 1, 1]
	]

func _get_origin_point() -> Vector2:
	return Vector2(3,1)

func refresh_terrain_struct() -> void:
	var origin_point = _get_origin_point()
	var battle_terrain_arr = _get_battle_terrain_arr()
	terrain_struct.set_struct(origin_point, battle_terrain_arr,[],[],[],[])

func get_terrain_grid() -> Array:
	return terrain_struct._battle_field
#endregion

#region 公共接口方法
# 提供给其他组件调用的方法
func get_current_turn() -> int:
	return current_turn

func is_battle_in_progress() -> bool:
	return is_battle_active

func get_active_character() -> GameCharacter:
	if turn_queue.size() > 0:
		return turn_queue[0]
	return null

func get_battle_participants() -> Array[GameCharacter]:
	return battle_participants.duplicate()

# 预留的轻量级全局接口（未来扩展用）
func get_battle_status() -> Dictionary:
	return {
		"is_active": is_battle_active,
		"current_turn": current_turn,
		"participants_count": battle_participants.size(),
		"active_character": get_active_character().name if get_active_character() else ""
	}
#endregion
