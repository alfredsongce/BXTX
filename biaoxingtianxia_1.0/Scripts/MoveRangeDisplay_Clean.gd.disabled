# 🚀 简化版移动范围显示系统 - 专注解决碰撞检测
extends Node2D
class_name MoveRangeDisplayClean

# 基本配置
@export var ground_color: Color = Color(0.0, 0.9, 0.0, 0.2)
@export var invalid_color: Color = Color(1.0, 0.0, 0.0, 0.3)
@export var highlight_color: Color = Color(1.0, 1.0, 0.0, 0.7)

# 核心变量
var character: GameCharacter = null
var center_position: Vector2 = Vector2.ZERO
var max_range: int = 0
var current_target: Vector2 = Vector2.ZERO
var is_valid_position: bool = true
var test_area: Area2D = null

# 调试控制
var debug_collision: bool = false

func _ready():
	set_process_input(true)
	visible = false
	_create_test_area()

# 🔧 创建测试Area2D（简化版）
func _create_test_area():
	test_area = Area2D.new()
	test_area.name = "TestArea"
	
	# 基本配置
	test_area.collision_layer = 4
	test_area.collision_mask = 4
	test_area.monitoring = true
	test_area.monitorable = true
	
	# 创建碰撞形状
	var collision_shape = CollisionShape2D.new()
	collision_shape.name = "TestShape"
	
	# 使用简单的圆形，避免胶囊复杂性
	var circle_shape = CircleShape2D.new()
	circle_shape.radius = 15.0  # 稍大于角色半径，确保能检测到
	collision_shape.shape = circle_shape
	
	# 添加到场景
	add_child(test_area)
	test_area.add_child(collision_shape)
	test_area.visible = false
	
	print("✅ [创建] test_area创建完成，半径15像素")

# 显示移动范围
func display_for_character(char: GameCharacter, pos: Vector2) -> void:
	character = char
	center_position = char.position
	max_range = char.qinggong_skill
	current_target = pos
	
	print("✅ [显示] 角色:%s, 位置:%s, 轻功:%d" % [char.name, center_position, max_range])
	
	visible = true
	queue_redraw()

# 隐藏移动范围
func hide_range() -> void:
	visible = false
	character = null

# 🎯 核心碰撞检测函数（专注解决Area2D问题）
func test_collision_at_position(test_pos: Vector2) -> bool:
	if not test_area or not character:
		print("❌ [碰撞] test_area或character为空")
		return false
	
	print("🔍 [碰撞测试] 开始测试位置: %s" % test_pos)
	
	# 1. 移动test_area到目标位置
	var original_pos = test_area.global_position
	test_area.global_position = test_pos
	
	# 2. 等待物理更新
	await get_tree().process_frame
	await get_tree().physics_frame
	
	# 3. 验证位置设置
	var actual_pos = test_area.global_position
	var distance_to_target = actual_pos.distance_to(test_pos)
	print("🔍 [位置] 目标:%s, 实际:%s, 误差:%.2f" % [test_pos, actual_pos, distance_to_target])
	
	if distance_to_target > 1.0:
		print("❌ [位置] 位置设置失败！")
		test_area.global_position = original_pos
		return false
	
	# 4. 检查重叠
	var overlapping_areas = test_area.get_overlapping_areas()
	print("🔍 [重叠] 重叠区域数量: %d" % overlapping_areas.size())
	
	# 5. 详细分析每个重叠区域
	var found_collision = false
	for i in range(overlapping_areas.size()):
		var area = overlapping_areas[i]
		var area_parent = area.get_parent()
		
		print("🔍 [重叠%d] Area: %s" % [i, area.name if area else "空"])
		print("         Parent: %s" % [area_parent.name if area_parent else "空"])
		
		# 检查是否为角色
		if area_parent and area_parent.is_in_group("party_members"):
			var char_data = area_parent.get_character_data() if area_parent.has_method("get_character_data") else null
			var char_name = char_data.name if char_data else "未知角色"
			
			print("         角色: %s" % char_name)
			
			# 跳过自己
			if char_data and character and char_data.id == character.id:
				print("         → 跳过自己")
				continue
			
			print("         ✅ 发现碰撞: %s" % char_name)
			found_collision = true
			break
	
	# 6. 如果没有找到重叠，诊断问题
	if not found_collision and overlapping_areas.size() == 0:
		print("🔍 [诊断] 没有重叠，开始诊断...")
		_diagnose_no_overlap(test_pos)
	
	# 7. 恢复位置
	test_area.global_position = original_pos
	
	print("🔍 [结果] %s" % ("有碰撞" if found_collision else "无碰撞"))
	return found_collision

# 🔧 诊断为什么没有重叠
func _diagnose_no_overlap(test_pos: Vector2):
	print("🚨 [诊断] 为什么在位置%s没有检测到重叠？" % test_pos)
	
	# 检查所有角色Area2D
	var party_members = get_tree().get_nodes_in_group("party_members")
	print("🔍 [诊断] 场景中角色数量: %d" % party_members.size())
	
	for member in party_members:
		var char_area = member.get_node_or_null("CharacterArea")
		if not char_area:
			continue
			
		var char_data = member.get_character_data() if member.has_method("get_character_data") else null
		var char_name = char_data.name if char_data else "未知"
		
		var distance = char_area.global_position.distance_to(test_pos)
		print("🔍 [角色] %s: 距离%.1f像素" % [char_name, distance])
		print("         Area位置: %s" % char_area.global_position)
		print("         监测状态: monitoring=%s, monitorable=%s" % [char_area.monitoring, char_area.monitorable])
		print("         碰撞层: layer=%d, mask=%d" % [char_area.collision_layer, char_area.collision_mask])
		
		# 检查碰撞形状
		var char_collision = null
		for child in char_area.get_children():
			if child is CollisionShape2D:
				char_collision = child
				break
		
		if char_collision and char_collision.shape:
			print("         碰撞形状位置: %s" % char_collision.global_position)
			if char_collision.shape is CapsuleShape2D:
				var capsule = char_collision.shape as CapsuleShape2D
				print("         形状: 胶囊 R%.1f H%.1f" % [capsule.radius, capsule.height])
			elif char_collision.shape is CircleShape2D:
				var circle = char_collision.shape as CircleShape2D
				print("         形状: 圆形 R%.1f" % circle.radius)
		
		# 🚨 特别关注柳生
		if char_name == "柳生" and distance < 30.0:
			print("🚨 [柳生] 距离%.1f < 30像素，理论上应该重叠！" % distance)
			
			# 手动计算重叠
			var test_radius = 15.0  # test_area的半径
			var yagyu_radius = 11.0  # 假设柳生胶囊半径
			var required_distance = test_radius + yagyu_radius  # 26像素
			
			print("🔍 [计算] test_area半径%.1f + 柳生半径%.1f = 应重叠距离%.1f" % [test_radius, yagyu_radius, required_distance])
			print("🔍 [计算] 实际距离%.1f %s 应重叠距离%.1f" % [distance, "<" if distance < required_distance else ">=", required_distance])
			
			if distance < required_distance:
				print("🚨 [柳生] 数学上应该重叠但Area2D没检测到！可能原因：")
				print("         1. 碰撞形状位置偏移")
				print("         2. Area2D更新延迟")
				print("         3. 碰撞层配置问题")
				print("         4. Godot引擎bug")

# 🎨 简化绘制
func _draw():
	if not visible or not character:
		return
	
	var local_center = to_local(center_position)
	
	# 绘制基本范围圆
	draw_circle(local_center, max_range, ground_color)
	draw_arc(local_center, max_range, 0, 2 * PI, 36, Color.WHITE, 2.0)
	
	# 绘制当前目标
	if current_target != center_position:
		var local_target = to_local(current_target)
		var color = highlight_color if is_valid_position else invalid_color
		draw_circle(local_target, 8, color)
	
	# 绘制调试信息
	var font = ThemeDB.fallback_font
	var debug_text = "简化版碰撞调试系统\n按T键测试当前鼠标位置碰撞\n按Y键切换调试模式"
	draw_string(font, Vector2(20, local_center.y - 60), debug_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color.WHITE)

# 🎯 输入处理（简化）
func _input(event):
	if not visible or not character:
		return
	
	if event is InputEventKey and event.pressed:
		match event.keycode:
			KEY_T:
				# 测试当前鼠标位置的碰撞
				print("=".repeat(50))
				print("🚀 [手动测试] 测试鼠标位置碰撞")
				var result = await test_collision_at_position(current_target)
				print("🚀 [手动测试] 结果: %s" % ("有碰撞" if result else "无碰撞"))
				print("=".repeat(50))
			KEY_Y:
				debug_collision = !debug_collision
				print("🔧 [调试] 碰撞调试模式: %s" % ("开启" if debug_collision else "关闭"))
	
	elif event is InputEventMouseMotion:
		current_target = event.position
		# 简单的有效性检查
		var distance = center_position.distance_to(current_target)
		is_valid_position = distance <= max_range
		queue_redraw()

# 信号
signal move_confirmed(target_position: Vector2, target_height: float, movement_cost: float) 
