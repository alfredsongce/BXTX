# ğŸš€ ç®€åŒ–ç‰ˆç§»åŠ¨èŒƒå›´æ˜¾ç¤ºç³»ç»Ÿ - ä¸“æ³¨è§£å†³ç¢°æ’æ£€æµ‹
extends Node2D
class_name MoveRangeDisplayClean

# åŸºæœ¬é…ç½®
@export var ground_color: Color = Color(0.0, 0.9, 0.0, 0.2)
@export var invalid_color: Color = Color(1.0, 0.0, 0.0, 0.3)
@export var highlight_color: Color = Color(1.0, 1.0, 0.0, 0.7)

# æ ¸å¿ƒå˜é‡
var character: GameCharacter = null
var center_position: Vector2 = Vector2.ZERO
var max_range: int = 0
var current_target: Vector2 = Vector2.ZERO
var is_valid_position: bool = true
var test_area: Area2D = null

# è°ƒè¯•æ§åˆ¶
var debug_collision: bool = false

func _ready():
	set_process_input(true)
	visible = false
	_create_test_area()

# ğŸ”§ åˆ›å»ºæµ‹è¯•Area2Dï¼ˆç®€åŒ–ç‰ˆï¼‰
func _create_test_area():
	test_area = Area2D.new()
	test_area.name = "TestArea"
	
	# åŸºæœ¬é…ç½®
	test_area.collision_layer = 4
	test_area.collision_mask = 4
	test_area.monitoring = true
	test_area.monitorable = true
	
	# åˆ›å»ºç¢°æ’å½¢çŠ¶
	var collision_shape = CollisionShape2D.new()
	collision_shape.name = "TestShape"
	
	# ä½¿ç”¨ç®€å•çš„åœ†å½¢ï¼Œé¿å…èƒ¶å›Šå¤æ‚æ€§
	var circle_shape = CircleShape2D.new()
	circle_shape.radius = 15.0  # ç¨å¤§äºè§’è‰²åŠå¾„ï¼Œç¡®ä¿èƒ½æ£€æµ‹åˆ°
	collision_shape.shape = circle_shape
	
	# æ·»åŠ åˆ°åœºæ™¯
	add_child(test_area)
	test_area.add_child(collision_shape)
	test_area.visible = false
	
	print("âœ… [åˆ›å»º] test_areaåˆ›å»ºå®Œæˆï¼ŒåŠå¾„15åƒç´ ")

# æ˜¾ç¤ºç§»åŠ¨èŒƒå›´
func display_for_character(char: GameCharacter, pos: Vector2) -> void:
	character = char
	center_position = char.position
	max_range = char.qinggong_skill
	current_target = pos
	
	print("âœ… [æ˜¾ç¤º] è§’è‰²:%s, ä½ç½®:%s, è½»åŠŸ:%d" % [char.name, center_position, max_range])
	
	visible = true
	queue_redraw()

# éšè—ç§»åŠ¨èŒƒå›´
func hide_range() -> void:
	visible = false
	character = null

# ğŸ¯ æ ¸å¿ƒç¢°æ’æ£€æµ‹å‡½æ•°ï¼ˆä¸“æ³¨è§£å†³Area2Dé—®é¢˜ï¼‰
func test_collision_at_position(test_pos: Vector2) -> bool:
	if not test_area or not character:
		print("âŒ [ç¢°æ’] test_areaæˆ–characterä¸ºç©º")
		return false
	
	print("ğŸ” [ç¢°æ’æµ‹è¯•] å¼€å§‹æµ‹è¯•ä½ç½®: %s" % test_pos)
	
	# 1. ç§»åŠ¨test_areaåˆ°ç›®æ ‡ä½ç½®
	var original_pos = test_area.global_position
	test_area.global_position = test_pos
	
	# 2. ç­‰å¾…ç‰©ç†æ›´æ–°
	await get_tree().process_frame
	await get_tree().physics_frame
	
	# 3. éªŒè¯ä½ç½®è®¾ç½®
	var actual_pos = test_area.global_position
	var distance_to_target = actual_pos.distance_to(test_pos)
	print("ğŸ” [ä½ç½®] ç›®æ ‡:%s, å®é™…:%s, è¯¯å·®:%.2f" % [test_pos, actual_pos, distance_to_target])
	
	if distance_to_target > 1.0:
		print("âŒ [ä½ç½®] ä½ç½®è®¾ç½®å¤±è´¥ï¼")
		test_area.global_position = original_pos
		return false
	
	# 4. æ£€æŸ¥é‡å 
	var overlapping_areas = test_area.get_overlapping_areas()
	print("ğŸ” [é‡å ] é‡å åŒºåŸŸæ•°é‡: %d" % overlapping_areas.size())
	
	# 5. è¯¦ç»†åˆ†ææ¯ä¸ªé‡å åŒºåŸŸ
	var found_collision = false
	for i in range(overlapping_areas.size()):
		var area = overlapping_areas[i]
		var area_parent = area.get_parent()
		
		print("ğŸ” [é‡å %d] Area: %s" % [i, area.name if area else "ç©º"])
		print("         Parent: %s" % [area_parent.name if area_parent else "ç©º"])
		
		# æ£€æŸ¥æ˜¯å¦ä¸ºè§’è‰²
		if area_parent and area_parent.is_in_group("party_members"):
			var char_data = area_parent.get_character_data() if area_parent.has_method("get_character_data") else null
			var char_name = char_data.name if char_data else "æœªçŸ¥è§’è‰²"
			
			print("         è§’è‰²: %s" % char_name)
			
			# è·³è¿‡è‡ªå·±
			if char_data and character and char_data.id == character.id:
				print("         â†’ è·³è¿‡è‡ªå·±")
				continue
			
			print("         âœ… å‘ç°ç¢°æ’: %s" % char_name)
			found_collision = true
			break
	
	# 6. å¦‚æœæ²¡æœ‰æ‰¾åˆ°é‡å ï¼Œè¯Šæ–­é—®é¢˜
	if not found_collision and overlapping_areas.size() == 0:
		print("ğŸ” [è¯Šæ–­] æ²¡æœ‰é‡å ï¼Œå¼€å§‹è¯Šæ–­...")
		_diagnose_no_overlap(test_pos)
	
	# 7. æ¢å¤ä½ç½®
	test_area.global_position = original_pos
	
	print("ğŸ” [ç»“æœ] %s" % ("æœ‰ç¢°æ’" if found_collision else "æ— ç¢°æ’"))
	return found_collision

# ğŸ”§ è¯Šæ–­ä¸ºä»€ä¹ˆæ²¡æœ‰é‡å 
func _diagnose_no_overlap(test_pos: Vector2):
	print("ğŸš¨ [è¯Šæ–­] ä¸ºä»€ä¹ˆåœ¨ä½ç½®%sæ²¡æœ‰æ£€æµ‹åˆ°é‡å ï¼Ÿ" % test_pos)
	
	# æ£€æŸ¥æ‰€æœ‰è§’è‰²Area2D
	var party_members = get_tree().get_nodes_in_group("party_members")
	print("ğŸ” [è¯Šæ–­] åœºæ™¯ä¸­è§’è‰²æ•°é‡: %d" % party_members.size())
	
	for member in party_members:
		var char_area = member.get_node_or_null("CharacterArea")
		if not char_area:
			continue
			
		var char_data = member.get_character_data() if member.has_method("get_character_data") else null
		var char_name = char_data.name if char_data else "æœªçŸ¥"
		
		var distance = char_area.global_position.distance_to(test_pos)
		print("ğŸ” [è§’è‰²] %s: è·ç¦»%.1fåƒç´ " % [char_name, distance])
		print("         Areaä½ç½®: %s" % char_area.global_position)
		print("         ç›‘æµ‹çŠ¶æ€: monitoring=%s, monitorable=%s" % [char_area.monitoring, char_area.monitorable])
		print("         ç¢°æ’å±‚: layer=%d, mask=%d" % [char_area.collision_layer, char_area.collision_mask])
		
		# æ£€æŸ¥ç¢°æ’å½¢çŠ¶
		var char_collision = null
		for child in char_area.get_children():
			if child is CollisionShape2D:
				char_collision = child
				break
		
		if char_collision and char_collision.shape:
			print("         ç¢°æ’å½¢çŠ¶ä½ç½®: %s" % char_collision.global_position)
			if char_collision.shape is CapsuleShape2D:
				var capsule = char_collision.shape as CapsuleShape2D
				print("         å½¢çŠ¶: èƒ¶å›Š R%.1f H%.1f" % [capsule.radius, capsule.height])
			elif char_collision.shape is CircleShape2D:
				var circle = char_collision.shape as CircleShape2D
				print("         å½¢çŠ¶: åœ†å½¢ R%.1f" % circle.radius)
		
		# ğŸš¨ ç‰¹åˆ«å…³æ³¨æŸ³ç”Ÿ
		if char_name == "æŸ³ç”Ÿ" and distance < 30.0:
			print("ğŸš¨ [æŸ³ç”Ÿ] è·ç¦»%.1f < 30åƒç´ ï¼Œç†è®ºä¸Šåº”è¯¥é‡å ï¼" % distance)
			
			# æ‰‹åŠ¨è®¡ç®—é‡å 
			var test_radius = 15.0  # test_areaçš„åŠå¾„
			var yagyu_radius = 11.0  # å‡è®¾æŸ³ç”Ÿèƒ¶å›ŠåŠå¾„
			var required_distance = test_radius + yagyu_radius  # 26åƒç´ 
			
			print("ğŸ” [è®¡ç®—] test_areaåŠå¾„%.1f + æŸ³ç”ŸåŠå¾„%.1f = åº”é‡å è·ç¦»%.1f" % [test_radius, yagyu_radius, required_distance])
			print("ğŸ” [è®¡ç®—] å®é™…è·ç¦»%.1f %s åº”é‡å è·ç¦»%.1f" % [distance, "<" if distance < required_distance else ">=", required_distance])
			
			if distance < required_distance:
				print("ğŸš¨ [æŸ³ç”Ÿ] æ•°å­¦ä¸Šåº”è¯¥é‡å ä½†Area2Dæ²¡æ£€æµ‹åˆ°ï¼å¯èƒ½åŸå› ï¼š")
				print("         1. ç¢°æ’å½¢çŠ¶ä½ç½®åç§»")
				print("         2. Area2Dæ›´æ–°å»¶è¿Ÿ")
				print("         3. ç¢°æ’å±‚é…ç½®é—®é¢˜")
				print("         4. Godotå¼•æ“bug")

# ğŸ¨ ç®€åŒ–ç»˜åˆ¶
func _draw():
	if not visible or not character:
		return
	
	var local_center = to_local(center_position)
	
	# ç»˜åˆ¶åŸºæœ¬èŒƒå›´åœ†
	draw_circle(local_center, max_range, ground_color)
	draw_arc(local_center, max_range, 0, 2 * PI, 36, Color.WHITE, 2.0)
	
	# ç»˜åˆ¶å½“å‰ç›®æ ‡
	if current_target != center_position:
		var local_target = to_local(current_target)
		var color = highlight_color if is_valid_position else invalid_color
		draw_circle(local_target, 8, color)
	
	# ç»˜åˆ¶è°ƒè¯•ä¿¡æ¯
	var font = ThemeDB.fallback_font
	var debug_text = "ç®€åŒ–ç‰ˆç¢°æ’è°ƒè¯•ç³»ç»Ÿ\næŒ‰Té”®æµ‹è¯•å½“å‰é¼ æ ‡ä½ç½®ç¢°æ’\næŒ‰Yé”®åˆ‡æ¢è°ƒè¯•æ¨¡å¼"
	draw_string(font, Vector2(20, local_center.y - 60), debug_text, HORIZONTAL_ALIGNMENT_LEFT, -1, 12, Color.WHITE)

# ğŸ¯ è¾“å…¥å¤„ç†ï¼ˆç®€åŒ–ï¼‰
func _input(event):
	if not visible or not character:
		return
	
	if event is InputEventKey and event.pressed:
		match event.keycode:
			KEY_T:
				# æµ‹è¯•å½“å‰é¼ æ ‡ä½ç½®çš„ç¢°æ’
				print("=".repeat(50))
				print("ğŸš€ [æ‰‹åŠ¨æµ‹è¯•] æµ‹è¯•é¼ æ ‡ä½ç½®ç¢°æ’")
				var result = await test_collision_at_position(current_target)
				print("ğŸš€ [æ‰‹åŠ¨æµ‹è¯•] ç»“æœ: %s" % ("æœ‰ç¢°æ’" if result else "æ— ç¢°æ’"))
				print("=".repeat(50))
			KEY_Y:
				debug_collision = !debug_collision
				print("ğŸ”§ [è°ƒè¯•] ç¢°æ’è°ƒè¯•æ¨¡å¼: %s" % ("å¼€å¯" if debug_collision else "å…³é—­"))
	
	elif event is InputEventMouseMotion:
		current_target = event.position
		# ç®€å•çš„æœ‰æ•ˆæ€§æ£€æŸ¥
		var distance = center_position.distance_to(current_target)
		is_valid_position = distance <= max_range
		queue_redraw()

# ä¿¡å·
signal move_confirmed(target_position: Vector2, target_height: float, movement_cost: float) 
