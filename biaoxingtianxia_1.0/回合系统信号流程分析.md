# 回合系统信号流程分析

## 概述
当前回合系统存在兰斯洛特回合被跳过的问题。本文档分析整个回合切换的信号流程，找出问题所在。

## 核心组件

### 1. TurnManager (Scripts/Battle/TurnManager.gd)
- **职责**：管理回合队列和当前角色
- **关键方法**：
  - `next_turn()`: 切换到下一个角色
  - `get_current_character()`: 获取当前角色
- **关键信号**：
  - `turn_changed`: 回合切换时发出

### 2. BattleEventManager (Scripts/Battle/BattleEventManager.gd)
- **职责**：统一处理战斗事件信号
- **关键方法**：
  - `request_next_character()`: 请求下一个角色回合
  - `_on_character_action_completed()`: 处理角色行动完成
- **监听信号**：
  - `character_action_completed`: 角色行动完成
  - `skill_execution_completed`: 技能执行完成

### 3. ActionSystemNew (Scripts/ActionSystemNew.gd)
- **职责**：处理玩家行动输入
- **发出信号**：
  - `character_action_completed`: 当角色行动点数耗尽时

### 4. BattleCombatManager (Scripts/Battle/BattleCombatManager.gd)
- **职责**：处理战斗逻辑
- **关键方法**：
  - `on_skill_executed()`: 技能执行完成处理
- **发出信号**：
  - `character_action_completed`: 技能完成后

### 5. SkillManager (Scripts/Battle/SkillManager.gd)
- **职责**：管理技能执行
- **发出信号**：
  - `skill_execution_completed`: 技能执行完成

## 正常的信号流程

### 休息行动流程
```
用户点击休息按钮
↓
ActionSystemNew._on_rest_button_pressed()
↓
ActionSystemNew._execute_non_move_action("rest")
↓
消耗行动点数 → 检查是否耗尽
↓
如果耗尽: battle_manager.character_action_completed.emit()
↓
BattleEventManager._on_character_action_completed()
↓
BattleEventManager.request_next_character()
↓
TurnManager.next_turn()
↓
发出turn_changed信号 → 切换到下一个角色
```

### 技能行动流程
```
用户点击技能按钮 → 选择技能 → 选择目标
↓
SkillManager.execute_skill()
↓
技能动画播放完成
↓
SkillManager.skill_execution_completed.emit()
↓
BattleEventManager._on_skill_execution_completed()
↓
BattleCombatManager.on_skill_executed()
↓
battle_manager.character_action_completed.emit()
↓
BattleEventManager._on_character_action_completed()
↓
BattleEventManager.request_next_character()
↓
TurnManager.next_turn()
↓
发出turn_changed信号 → 切换到下一个角色
```

### 移动行动流程
```
用户点击移动按钮 → 选择目标位置 → 确认
↓
ActionSystemNew._on_move_confirmed_new()
↓
消耗移动点数 → 检查是否耗尽
↓
如果耗尽: battle_manager.character_action_completed.emit()
↓
后续流程同休息行动
```

## 问题分析

### 当前问题现象
从日志可以看到：
1. ✅ 柳生技能执行完成，正确切换到兰斯洛特
2. ✅ 兰斯洛特菜单成功打开
3. ❌ **菜单打开完成后，又立即触发了第二次REQUEST_NEXT_CHARACTER**

### 可能的问题原因

#### 1. 重复信号处理
- SkillManager发出的信号被多个组件同时监听
- BattleFlowManager和BattleEventManager都可能处理同一个信号

#### 2. 延迟信号触发
- 技能动画或效果处理可能有延迟回调
- 菜单打开过程中的某个操作触发了回合切换

#### 3. 信号连接重复
- 同一个信号可能被连接了多次
- 导致一个事件触发多次回调

## 调试策略

### 1. 信号追踪
在所有发出character_action_completed信号的地方添加唯一标识：
- ActionSystemNew: "ACTION_SYSTEM"
- BattleCombatManager: "COMBAT_MANAGER"  
- BattleScene: "BATTLE_SCENE"

### 2. 调用栈追踪
在BattleEventManager.request_next_character()中打印调用栈

### 3. 时间戳追踪
记录每个信号发出的准确时间，分析时序问题

### 4. 信号连接检查
检查每个signal的连接数量，确认是否有重复连接

## 已实施的调试功能

### 1. 信号来源追踪 ✅
- **ActionSystemNew**: 在所有`character_action_completed.emit()`调用前添加时间戳和来源标识
  - `ACTION_SYSTEM_NON_MOVE`: 非移动行动（休息、技能等）
  - `ACTION_SYSTEM_MOVE`: 移动+回合结束
  - `ACTION_SYSTEM_MOVE_ONLY`: 仅移动，回合不结束
- **BattleCombatManager**: 在`on_skill_executed()`中添加`COMBAT_MANAGER_SKILL`标识

### 2. 调用栈追踪 ✅
- **BattleEventManager.request_next_character()**: 显示前5层调用栈，可以看到是谁调用了回合切换

### 3. 信号分析 ✅  
- **BattleEventManager._on_character_action_completed()**: 
  - 分析收到的`action_result.type`，判断信号来源
  - 根据行动类型决定是否应该切换回合
  - 区分`move_only`（不切换回合）和其他类型（切换回合）

### 4. 自动状态输出 ✅
- **ActionSystemNew**: 在关键行动完成后自动调用`_print_turn_debug_info()`
- **TurnManager**: debug_logging_enabled设置为true，显示详细的回合切换日志

## 下一步测试
现在请重新测试 "觉远：移动+休息；柳生：移动+技能" 的场景，新的调试信息会显示：

1. **每个信号的准确时间戳**
2. **信号的来源标识**（ACTION_SYSTEM vs COMBAT_MANAGER）
3. **谁调用了request_next_character** (调用栈)
4. **每个信号的行动类型分析**
5. **是否应该切换回合的判断逻辑**

这样可以清楚地看到是否有重复的信号，以及第二次回合切换是从哪里触发的。 