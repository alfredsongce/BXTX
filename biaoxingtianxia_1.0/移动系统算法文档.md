# 移动系统算法详细文档

## 目录
1. [系统概览](#系统概览)
2. [核心数据结构](#核心数据结构)
3. [移动计算算法](#移动计算算法)
4. [渲染算法详解](#渲染算法详解)
5. [碰撞检测系统](#碰撞检测系统)
6. [性能优化策略](#性能优化策略)
7. [调试系统](#调试系统)
8. [配置参数说明](#配置参数说明)

---

## 系统概览

移动范围显示系统是一个复杂的3D移动计算和可视化系统，主要特点：

- **3D移动支持**：支持水平移动和垂直高度变化
- **轻功值限制**：基于角色轻功值计算可移动范围
- **实时渲染**：提供两种高精度渲染模式
- **碰撞检测**：防止角色重叠
- **性能优化**：多层次性能优化策略

### 坐标系统

```
地面基准Y坐标 (base_ground_y)
    ↓
    |--- 角色当前位置 (center_position)
    |--- 目标位置计算基于地面基准
    |--- 高度 = (base_ground_y - world_y) / grid_step
```

---

## 核心数据结构

### 主要变量

```gdscript
# 位置和范围
var center_position: Vector2        # 角色圆心位置（包含当前高度）
var base_ground_y: float           # 地面基准Y坐标（高度计算基准）
var max_range: int                 # 最大移动范围（轻功值像素）
var current_target: Vector2        # 当前选中目标位置
var current_height: float          # 当前选中位置的高度
var grid_step: float = 40.0        # 每单位高度对应的像素值

# 状态标记
var is_valid_position: bool        # 当前位置是否在轻功范围内
var is_position_occupied: bool     # 当前位置是否被其他角色占据
```

### 配置参数

```gdscript
# 渲染模式控制
@export var sector_rendering: bool = true     # 扇形渲染模式
@export var continuous_rendering: bool = true # 连续绘制（消除空隙）
@export var smooth_rendering: bool = true     # 平滑圆润绘制
@export var sector_count: int = 36           # 扇形数量（性能vs精度）
@export var radial_divisions: int = 10       # 径向分割数（距离层次）

# 性能优化
@export var performance_mode: bool = false   # 性能模式
@export var grid_detection_size: int = 16    # 网格检测大小
```

---

## 移动计算算法

### 3D距离计算

系统使用欧几里得距离计算3D空间中的移动消耗：

```gdscript
func _calculate_move_distance(target_pos: Vector2, target_height: float) -> float:
    var char_ground_pos = character.ground_position
    var current_char_height = character.get_height_level()
    
    # 水平距离计算
    var horizontal_distance = abs(target_pos.x - char_ground_pos.x)
    
    # 高度变化像素计算
    var height_diff_pixels = abs(target_height - current_char_height) * grid_step
    
    # 3D欧几里得距离
    var move_distance = sqrt(pow(horizontal_distance, 2) + pow(height_diff_pixels, 2))
    
    return move_distance
```

### 高度计算逻辑

高度计算基于地面基准位置，确保一致性：

```gdscript
func _calculate_target_height(mouse_y: float) -> float:
    # 计算鼠标Y位置与地面基准的差值
    var y_diff_from_ground = base_ground_y - mouse_y
    
    if y_diff_from_ground >= 0:
        # 鼠标在地面上方，计算增加的高度
        var target_height = y_diff_from_ground / grid_step
        return max(0.0, target_height)  # 防止负高度
    else:
        # 鼠标在地面下方，不允许移动到地下
        return 0.0
```

### 移动有效性检查

```gdscript
func _check_position_movability_optimized(world_pos: Vector2, char_ground_pos: Vector2, 
                                         current_char_height: float, max_height_level: float) -> bool:
    # 1. 水平距离检查
    var horizontal_distance = abs(world_pos.x - char_ground_pos.x)
    if horizontal_distance > max_range:
        return false
    
    # 2. 高度计算和限制检查
    var y_offset = world_pos.y - base_ground_y
    if y_offset > 0:  # 地面下方不可移动
        return false
    
    var target_height = -y_offset / grid_step
    if target_height < 0 or target_height > max_height_level:
        return false
    
    # 3. 3D距离检查
    var height_diff_pixels = abs(target_height - current_char_height) * grid_step
    var move_distance = sqrt(pow(horizontal_distance, 2) + pow(height_diff_pixels, 2))
    if move_distance > max_range:
        return false
    
    # 4. 边界严格程度检查（98%以上距离时稍微限制）
    var distance_ratio = move_distance / float(max_range)
    if distance_ratio > 0.98 and move_distance > (max_range * 0.99):
        return false
    
    # 5. 碰撞检测
    return not _check_collision_at_position_fast(Vector2(world_pos.x, char_ground_pos.y - (target_height * grid_step)))
```

---

## 渲染算法详解

### 双模式渲染架构

系统提供两种渲染模式，通过 `sector_rendering` 参数切换：

#### 1. 扇形渲染模式（推荐）

**核心思想**：将圆形移动范围分割成多个扇形，每个扇形内部再分成径向环带，实现精确的位置级颜色显示。

```gdscript
func _draw_sector_move_range(local_center: Vector2, current_char_height: float) -> void:
    var sector_angle = 360.0 / sector_count  # 每个扇形的角度
    var gap_angle = sector_gap_degrees        # 扇形间隙
    
    # 绘制每个扇形
    for i in range(sector_count):
        var start_angle = i * sector_angle + gap_angle * 0.5
        var end_angle = (i + 1) * sector_angle - gap_angle * 0.5
        
        # 精确绘制扇形内部的颜色分布
        _draw_sector_with_position_colors(local_center, start_angle, end_angle, 
                                        char_ground_pos, current_char_height, max_height_level)
```

**扇形内部径向环带渲染**：

```gdscript
func _draw_sector_with_position_colors(local_center: Vector2, start_angle: float, end_angle: float,
                                      char_ground_pos: Vector2, current_char_height: float, max_height_level: float) -> void:
    var radial_steps = radial_divisions
    var step_size = max_range / radial_steps
    
    # 将扇形分成多个径向带
    for ring in range(radial_steps):
        var inner_radius = ring * step_size
        var outer_radius = (ring + 1) * step_size
        
        # 采样这个径向带的可移动性
        var ring_movability = _sample_radial_ring_movability(...)
        
        # 计算距离比例和颜色
        var distance_ratio = float(ring + 1) / float(radial_steps)
        var ring_color = _get_smooth_sector_color(ring_movability, distance_ratio)
        
        # 绘制环形扇形
        _draw_sector_ring(local_center, inner_radius, outer_radius, start_angle, end_angle, ring_color)
```

#### 2. 网格渲染模式

**核心思想**：使用传统的2D网格采样，然后将连通的可移动区域合并绘制。

```gdscript
func _draw_grid_move_range(local_center: Vector2, current_char_height: float) -> void:
    var grid_size = grid_detection_size
    var check_radius = max_range
    
    # 创建2D网格存储检测结果
    var grid_width = int((check_radius * 2) / grid_size) + 1
    var grid_height = int((check_radius * 2) / grid_size) + 1
    var movability_grid = []
    
    # 网格采样
    for i in range(grid_width):
        for j in range(grid_height):
            var world_pos = center_position + Vector2(x, y)
            var is_movable = _check_position_movability_optimized(...)
            movability_grid[i][j] = is_movable
    
    # 绘制连续区域
    _draw_movability_regions(movability_grid, local_center, grid_size, check_radius)
```

### 径向环带采样算法

这是扇形渲染的核心算法，用于精确计算每个环带的可移动性：

```gdscript
func _sample_radial_ring_movability(local_center: Vector2, start_angle: float, end_angle: float,
                                   inner_radius: float, outer_radius: float, ...) -> float:
    var total_samples = 0
    var movable_samples = 0
    
    # 采样参数（性能vs精度平衡）
    var angle_step = performance_mode ? 2.5 : 1.5  # 角度步长
    var radius_step = performance_mode ? 6.0 : 4.0  # 半径步长
    
    # 在径向环带内采样
    var radius = inner_radius + radius_step
    while radius <= outer_radius:
        var angle = start_angle
        while angle <= end_angle:
            var rad = deg_to_rad(angle)
            var offset = Vector2(cos(rad), sin(rad)) * radius
            var world_pos = center_position + offset
            
            total_samples += 1
            if _check_position_movability_optimized(world_pos, ...):
                movable_samples += 1
            
            angle += angle_step
        radius += radius_step
    
    return float(movable_samples) / float(max(total_samples, 1))
```

### 颜色计算算法

系统使用智能颜色映射，根据可移动性比例和距离比例动态调整：

```gdscript
func _get_smooth_sector_color(movability_ratio: float, distance_ratio: float) -> Color:
    var is_edge_area = distance_ratio > 0.9  # 边缘区域更严格
    var base_color: Color
    
    if is_edge_area:
        # 边缘区域：更严格的阈值
        if movability_ratio >= 0.8:     # 需要80%以上才显示绿色
            base_color = movable_area_color
        elif movability_ratio >= 0.6:   # 60%以上显示黄色
            var t = (movability_ratio - 0.6) / 0.2
            base_color = partial_movable_color.lerp(movable_area_color, t)
        elif movability_ratio >= 0.4:   # 40%以上显示橙色
            var t = (movability_ratio - 0.4) / 0.2
            base_color = barely_movable_color.lerp(partial_movable_color, t)
        else:
            base_color = unmovable_area_color
    else:
        # 内部区域：保持宽松阈值
        # ... 类似逻辑但阈值更宽松
    
    # 距离偏移效果（可选）
    if not disable_distance_offset:
        var distance_influence = (1.0 - movability_ratio) * 0.5
        if distance_ratio > 0.85:
            var red_shift = (distance_ratio - 0.85) / 0.15 * distance_influence * 0.08
            base_color = base_color.lerp(unmovable_area_color, red_shift)
    
    return base_color
```

### 环形扇形绘制

```gdscript
func _draw_sector_ring(center: Vector2, inner_radius: float, outer_radius: float, 
                      start_angle: float, end_angle: float, color: Color) -> void:
    var points = PackedVector2Array()
    var angle_step = 2.0  # 每2度一个点
    
    # 添加外弧的点
    var angle = start_angle
    while angle <= end_angle:
        var rad = deg_to_rad(angle)
        var point = center + Vector2(cos(rad), sin(rad)) * outer_radius
        points.append(point)
        angle += angle_step
    
    # 添加内弧的点（逆序）
    angle = end_angle
    while angle >= start_angle:
        var rad = deg_to_rad(angle)
        var point = center + Vector2(cos(rad), sin(rad)) * inner_radius
        points.append(point)
        angle -= angle_step
    
    # 绘制填充的环形扇形
    if points.size() >= 3:
        draw_colored_polygon(points, color)
        
        # 可选：渐变边缘效果
        if use_gradient_effect and smooth_color_transition:
            var soft_color = Color(color.r, color.g, color.b, color.a * 0.6)
            # 绘制柔化边缘...
```

---

## 碰撞检测系统

### 动态碰撞形状复制

系统使用动态Area2D进行碰撞检测，自动复制角色的碰撞形状：

```gdscript
func update_test_area_shape(char_node: Node2D) -> void:
    var char_area = char_node.get_node_or_null("CharacterArea")
    var char_collision_shape = # 查找角色的碰撞形状
    
    # 复制到测试区域
    var test_collision_shape = test_area.get_node_or_null("TestCollisionShape")
    test_collision_shape.shape = char_collision_shape.shape.duplicate()
```

### 异步碰撞检测

```gdscript
func _check_target_collision(target_pos: Vector2) -> void:
    test_area.global_position = target_pos
    
    # 等待一帧确保碰撞检测更新
    await get_tree().process_frame
    
    var overlapping_areas = test_area.get_overlapping_areas()
    is_position_occupied = false
    
    for area in overlapping_areas:
        var area_parent = area.get_parent()
        
        # 通过ID比较跳过自己
        if character and area_parent.is_in_group("party_members"):
            var other_char = # 获取其他角色数据
            if other_char and character.id == other_char.id:
                continue  # 跳过自己
            
            is_position_occupied = true
            break
    
    queue_redraw()  # 更新显示
```

---

## 性能优化策略

### 多层次采样优化

```gdscript
# 性能模式参数调整
var angle_step = performance_mode ? 2.5 : 1.5    # 角度采样精度
var radius_step = performance_mode ? 6.0 : 4.0   # 半径采样精度
var radial_divisions = performance_mode ? 8 : 10  # 径向分割数量
```

### 早期退出优化

```gdscript
func _check_position_movability_optimized(...) -> bool:
    # 1. 最快的检查：水平距离
    var horizontal_distance = abs(world_pos.x - char_ground_pos.x)
    if horizontal_distance > max_range:
        return false  # 立即退出
    
    # 2. 地面检查
    var y_offset = world_pos.y - base_ground_y
    if y_offset > 0:
        return false  # 立即退出
    
    # 3. 更复杂的3D距离计算...
```

### 缓存和预计算

```gdscript
# 预计算常用值
var max_height_level = max_range / grid_step
var char_ground_pos_cached = char_ground_pos

# 缓存碰撞检测结果
var collision_cache = {}
```

### 区域裁剪

```gdscript
# 只检测圆形范围内的区域
var distance_to_center = Vector2(x, y).length()
if distance_to_center > max_range:
    continue  # 跳过超出范围的区域
```

---

## 调试系统

### 象限调试

按键1-4可以单独显示特定象限，便于调试不对称问题：

```gdscript
func _draw_debug_quadrant(center: Vector2, quadrant: int) -> void:
    var start_angle, end_angle: float
    match quadrant:
        1: start_angle = 0.0; end_angle = 90.0      # 右下
        2: start_angle = 90.0; end_angle = 180.0    # 左下
        3: start_angle = 180.0; end_angle = 270.0   # 左上
        4: start_angle = 270.0; end_angle = 360.0   # 右上
    
    _draw_filled_sector(center, max_range, start_angle, end_angle, Color.CYAN)
```

### 鼠标点击调试

按I键启用鼠标调试模式，点击任意位置显示详细的采样信息：

```gdscript
func _debug_mouse_position(mouse_pos: Vector2) -> void:
    # 计算角度、距离、所属扇形
    var offset = mouse_pos - center_position
    var angle_deg = rad_to_deg(atan2(offset.y, offset.x))
    var sector_index = int(angle_deg / (360.0 / sector_count))
    
    # 显示详细采样信息
    print("扇形索引: %d, 可移动性: %.2f%%" % [sector_index, movability * 100])
```

### 性能监控

```gdscript
# 实时显示采样信息
var debug_text = "采样参数: 角度步长%.1f°, 半径步长%.1fpx" % [angle_step, radius_step]
draw_string(font, debug_pos, debug_text, ...)
```

---

## 配置参数说明

### 核心渲染参数| 参数 | 默认值 | 说明 ||------|--------|------|| `sector_rendering` | true | 启用扇形渲染模式（推荐） || `sector_count` | 36 | 扇形数量，影响精度和性能 || `radial_divisions` | 10 | 径向分割数，控制距离层次精细度 || `continuous_rendering` | true | 连续绘制模式，消除空隙 || `smooth_rendering` | true | 平滑圆润绘制 |### 🎨 颜色系统参数（新增）| 参数 | 默认值 | 说明 ||------|--------|------|| `simple_color_mode` | true | **简单颜色模式：只有绿色和红色** || `movability_threshold` | 0.5 | 可移动性阈值（50%以上显示绿色） || `movable_area_color` | 绿色 | 可移动区域颜色 || `unmovable_area_color` | 红色 | 不可移动区域颜色 |

### 性能优化参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `performance_mode` | false | 性能模式：降低精度提高速度 |
| `grid_detection_size` | 16 | 网格检测大小（像素） |
| `smooth_color_transition` | true | 平滑颜色过渡 |

### 调试参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `disable_distance_offset` | false | 禁用距离偏移效果 |
| `show_unmovable_areas` | true | 显示不可移动区域 |
| `use_gradient_effect` | true | 使用渐变效果 |

### 推荐配置

**🎨 简单颜色模式**（推荐）：```gdscriptsimple_color_mode = true        # 简单二元颜色movability_threshold = 0.5      # 50%阈值sector_rendering = truesector_count = 36```**高质量复杂模式**：```gdscriptsimple_color_mode = false       # 多级颜色显示sector_rendering = truesector_count = 36radial_divisions = 10performance_mode = false```**性能模式**：```gdscriptsimple_color_mode = true        # 简单颜色提高性能sector_rendering = truesector_count = 24               # 减少扇形数量radial_divisions = 8            # 减少径向分割performance_mode = true         # 启用性能模式```**调试模式**：```gdscriptsimple_color_mode = false       # 使用复杂颜色便于调试disable_distance_offset = true  # 纯可移动性显示show_unmovable_areas = true     # 显示问题区域```

---

## 算法复杂度分析

### 扇形渲染模式

**时间复杂度**：O(S × R × A × D)
- S: sector_count (扇形数量)
- R: radial_divisions (径向分割数)
- A: 角度采样点数 ≈ (sector_angle / angle_step)
- D: 径向采样点数 ≈ (ring_width / radius_step)

**空间复杂度**：O(1) - 只使用临时变量

### 网格渲染模式

**时间复杂度**：O(W × H + C)
- W: 网格宽度 ≈ (2 × max_range / grid_size)
- H: 网格高度 ≈ (2 × max_range / grid_size)
- C: 连通区域查找复杂度

**空间复杂度**：O(W × H) - 需要存储整个网格

### 性能对比

在相同精度下，扇形渲染通常比网格渲染更高效，因为：
1. 只计算圆形范围内的区域
2. 径向采样密度可根据距离动态调整
3. 无需存储大量网格数据

---

## 总结

该移动系统算法的核心优势：

1. **精确性**：扇形+径向环带的双重分割确保位置级精度
2. **性能**：多层次优化策略，支持实时渲染
3. **可配置性**：丰富的参数配置，适应不同需求
4. **可调试性**：完善的调试系统，便于问题定位
5. **扩展性**：模块化设计，易于添加新功能

该系统能够在保证视觉效果的同时，提供出色的性能表现，是一个成熟的游戏移动系统解决方案。 