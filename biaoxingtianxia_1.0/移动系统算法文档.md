# ç§»åŠ¨ç³»ç»Ÿç®—æ³•è¯¦ç»†æ–‡æ¡£

## ç›®å½•
1. [ç³»ç»Ÿæ¦‚è§ˆ](#ç³»ç»Ÿæ¦‚è§ˆ)
2. [æ ¸å¿ƒæ•°æ®ç»“æ„](#æ ¸å¿ƒæ•°æ®ç»“æ„)
3. [ç§»åŠ¨è®¡ç®—ç®—æ³•](#ç§»åŠ¨è®¡ç®—ç®—æ³•)
4. [æ¸²æŸ“ç®—æ³•è¯¦è§£](#æ¸²æŸ“ç®—æ³•è¯¦è§£)
5. [ç¢°æ’æ£€æµ‹ç³»ç»Ÿ](#ç¢°æ’æ£€æµ‹ç³»ç»Ÿ)
6. [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
7. [è°ƒè¯•ç³»ç»Ÿ](#è°ƒè¯•ç³»ç»Ÿ)
8. [é…ç½®å‚æ•°è¯´æ˜](#é…ç½®å‚æ•°è¯´æ˜)

---

## ç³»ç»Ÿæ¦‚è§ˆ

ç§»åŠ¨èŒƒå›´æ˜¾ç¤ºç³»ç»Ÿæ˜¯ä¸€ä¸ªå¤æ‚çš„3Dç§»åŠ¨è®¡ç®—å’Œå¯è§†åŒ–ç³»ç»Ÿï¼Œä¸»è¦ç‰¹ç‚¹ï¼š

- **3Dç§»åŠ¨æ”¯æŒ**ï¼šæ”¯æŒæ°´å¹³ç§»åŠ¨å’Œå‚ç›´é«˜åº¦å˜åŒ–
- **è½»åŠŸå€¼é™åˆ¶**ï¼šåŸºäºè§’è‰²è½»åŠŸå€¼è®¡ç®—å¯ç§»åŠ¨èŒƒå›´
- **å®æ—¶æ¸²æŸ“**ï¼šæä¾›ä¸¤ç§é«˜ç²¾åº¦æ¸²æŸ“æ¨¡å¼
- **ç¢°æ’æ£€æµ‹**ï¼šé˜²æ­¢è§’è‰²é‡å 
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå¤šå±‚æ¬¡æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### åæ ‡ç³»ç»Ÿ

```
åœ°é¢åŸºå‡†Yåæ ‡ (base_ground_y)
    â†“
    |--- è§’è‰²å½“å‰ä½ç½® (center_position)
    |--- ç›®æ ‡ä½ç½®è®¡ç®—åŸºäºåœ°é¢åŸºå‡†
    |--- é«˜åº¦ = (base_ground_y - world_y) / grid_step
```

---

## æ ¸å¿ƒæ•°æ®ç»“æ„

### ä¸»è¦å˜é‡

```gdscript
# ä½ç½®å’ŒèŒƒå›´
var center_position: Vector2        # è§’è‰²åœ†å¿ƒä½ç½®ï¼ˆåŒ…å«å½“å‰é«˜åº¦ï¼‰
var base_ground_y: float           # åœ°é¢åŸºå‡†Yåæ ‡ï¼ˆé«˜åº¦è®¡ç®—åŸºå‡†ï¼‰
var max_range: int                 # æœ€å¤§ç§»åŠ¨èŒƒå›´ï¼ˆè½»åŠŸå€¼åƒç´ ï¼‰
var current_target: Vector2        # å½“å‰é€‰ä¸­ç›®æ ‡ä½ç½®
var current_height: float          # å½“å‰é€‰ä¸­ä½ç½®çš„é«˜åº¦
var grid_step: float = 40.0        # æ¯å•ä½é«˜åº¦å¯¹åº”çš„åƒç´ å€¼

# çŠ¶æ€æ ‡è®°
var is_valid_position: bool        # å½“å‰ä½ç½®æ˜¯å¦åœ¨è½»åŠŸèŒƒå›´å†…
var is_position_occupied: bool     # å½“å‰ä½ç½®æ˜¯å¦è¢«å…¶ä»–è§’è‰²å æ®
```

### é…ç½®å‚æ•°

```gdscript
# æ¸²æŸ“æ¨¡å¼æ§åˆ¶
@export var sector_rendering: bool = true     # æ‰‡å½¢æ¸²æŸ“æ¨¡å¼
@export var continuous_rendering: bool = true # è¿ç»­ç»˜åˆ¶ï¼ˆæ¶ˆé™¤ç©ºéš™ï¼‰
@export var smooth_rendering: bool = true     # å¹³æ»‘åœ†æ¶¦ç»˜åˆ¶
@export var sector_count: int = 36           # æ‰‡å½¢æ•°é‡ï¼ˆæ€§èƒ½vsç²¾åº¦ï¼‰
@export var radial_divisions: int = 10       # å¾„å‘åˆ†å‰²æ•°ï¼ˆè·ç¦»å±‚æ¬¡ï¼‰

# æ€§èƒ½ä¼˜åŒ–
@export var performance_mode: bool = false   # æ€§èƒ½æ¨¡å¼
@export var grid_detection_size: int = 16    # ç½‘æ ¼æ£€æµ‹å¤§å°
```

---

## ç§»åŠ¨è®¡ç®—ç®—æ³•

### 3Dè·ç¦»è®¡ç®—

ç³»ç»Ÿä½¿ç”¨æ¬§å‡ é‡Œå¾—è·ç¦»è®¡ç®—3Dç©ºé—´ä¸­çš„ç§»åŠ¨æ¶ˆè€—ï¼š

```gdscript
func _calculate_move_distance(target_pos: Vector2, target_height: float) -> float:
    var char_ground_pos = character.ground_position
    var current_char_height = character.get_height_level()
    
    # æ°´å¹³è·ç¦»è®¡ç®—
    var horizontal_distance = abs(target_pos.x - char_ground_pos.x)
    
    # é«˜åº¦å˜åŒ–åƒç´ è®¡ç®—
    var height_diff_pixels = abs(target_height - current_char_height) * grid_step
    
    # 3Dæ¬§å‡ é‡Œå¾—è·ç¦»
    var move_distance = sqrt(pow(horizontal_distance, 2) + pow(height_diff_pixels, 2))
    
    return move_distance
```

### é«˜åº¦è®¡ç®—é€»è¾‘

é«˜åº¦è®¡ç®—åŸºäºåœ°é¢åŸºå‡†ä½ç½®ï¼Œç¡®ä¿ä¸€è‡´æ€§ï¼š

```gdscript
func _calculate_target_height(mouse_y: float) -> float:
    # è®¡ç®—é¼ æ ‡Yä½ç½®ä¸åœ°é¢åŸºå‡†çš„å·®å€¼
    var y_diff_from_ground = base_ground_y - mouse_y
    
    if y_diff_from_ground >= 0:
        # é¼ æ ‡åœ¨åœ°é¢ä¸Šæ–¹ï¼Œè®¡ç®—å¢åŠ çš„é«˜åº¦
        var target_height = y_diff_from_ground / grid_step
        return max(0.0, target_height)  # é˜²æ­¢è´Ÿé«˜åº¦
    else:
        # é¼ æ ‡åœ¨åœ°é¢ä¸‹æ–¹ï¼Œä¸å…è®¸ç§»åŠ¨åˆ°åœ°ä¸‹
        return 0.0
```

### ç§»åŠ¨æœ‰æ•ˆæ€§æ£€æŸ¥

```gdscript
func _check_position_movability_optimized(world_pos: Vector2, char_ground_pos: Vector2, 
                                         current_char_height: float, max_height_level: float) -> bool:
    # 1. æ°´å¹³è·ç¦»æ£€æŸ¥
    var horizontal_distance = abs(world_pos.x - char_ground_pos.x)
    if horizontal_distance > max_range:
        return false
    
    # 2. é«˜åº¦è®¡ç®—å’Œé™åˆ¶æ£€æŸ¥
    var y_offset = world_pos.y - base_ground_y
    if y_offset > 0:  # åœ°é¢ä¸‹æ–¹ä¸å¯ç§»åŠ¨
        return false
    
    var target_height = -y_offset / grid_step
    if target_height < 0 or target_height > max_height_level:
        return false
    
    # 3. 3Dè·ç¦»æ£€æŸ¥
    var height_diff_pixels = abs(target_height - current_char_height) * grid_step
    var move_distance = sqrt(pow(horizontal_distance, 2) + pow(height_diff_pixels, 2))
    if move_distance > max_range:
        return false
    
    # 4. è¾¹ç•Œä¸¥æ ¼ç¨‹åº¦æ£€æŸ¥ï¼ˆ98%ä»¥ä¸Šè·ç¦»æ—¶ç¨å¾®é™åˆ¶ï¼‰
    var distance_ratio = move_distance / float(max_range)
    if distance_ratio > 0.98 and move_distance > (max_range * 0.99):
        return false
    
    # 5. ç¢°æ’æ£€æµ‹
    return not _check_collision_at_position_fast(Vector2(world_pos.x, char_ground_pos.y - (target_height * grid_step)))
```

---

## æ¸²æŸ“ç®—æ³•è¯¦è§£

### åŒæ¨¡å¼æ¸²æŸ“æ¶æ„

ç³»ç»Ÿæä¾›ä¸¤ç§æ¸²æŸ“æ¨¡å¼ï¼Œé€šè¿‡ `sector_rendering` å‚æ•°åˆ‡æ¢ï¼š

#### 1. æ‰‡å½¢æ¸²æŸ“æ¨¡å¼ï¼ˆæ¨èï¼‰

**æ ¸å¿ƒæ€æƒ³**ï¼šå°†åœ†å½¢ç§»åŠ¨èŒƒå›´åˆ†å‰²æˆå¤šä¸ªæ‰‡å½¢ï¼Œæ¯ä¸ªæ‰‡å½¢å†…éƒ¨å†åˆ†æˆå¾„å‘ç¯å¸¦ï¼Œå®ç°ç²¾ç¡®çš„ä½ç½®çº§é¢œè‰²æ˜¾ç¤ºã€‚

```gdscript
func _draw_sector_move_range(local_center: Vector2, current_char_height: float) -> void:
    var sector_angle = 360.0 / sector_count  # æ¯ä¸ªæ‰‡å½¢çš„è§’åº¦
    var gap_angle = sector_gap_degrees        # æ‰‡å½¢é—´éš™
    
    # ç»˜åˆ¶æ¯ä¸ªæ‰‡å½¢
    for i in range(sector_count):
        var start_angle = i * sector_angle + gap_angle * 0.5
        var end_angle = (i + 1) * sector_angle - gap_angle * 0.5
        
        # ç²¾ç¡®ç»˜åˆ¶æ‰‡å½¢å†…éƒ¨çš„é¢œè‰²åˆ†å¸ƒ
        _draw_sector_with_position_colors(local_center, start_angle, end_angle, 
                                        char_ground_pos, current_char_height, max_height_level)
```

**æ‰‡å½¢å†…éƒ¨å¾„å‘ç¯å¸¦æ¸²æŸ“**ï¼š

```gdscript
func _draw_sector_with_position_colors(local_center: Vector2, start_angle: float, end_angle: float,
                                      char_ground_pos: Vector2, current_char_height: float, max_height_level: float) -> void:
    var radial_steps = radial_divisions
    var step_size = max_range / radial_steps
    
    # å°†æ‰‡å½¢åˆ†æˆå¤šä¸ªå¾„å‘å¸¦
    for ring in range(radial_steps):
        var inner_radius = ring * step_size
        var outer_radius = (ring + 1) * step_size
        
        # é‡‡æ ·è¿™ä¸ªå¾„å‘å¸¦çš„å¯ç§»åŠ¨æ€§
        var ring_movability = _sample_radial_ring_movability(...)
        
        # è®¡ç®—è·ç¦»æ¯”ä¾‹å’Œé¢œè‰²
        var distance_ratio = float(ring + 1) / float(radial_steps)
        var ring_color = _get_smooth_sector_color(ring_movability, distance_ratio)
        
        # ç»˜åˆ¶ç¯å½¢æ‰‡å½¢
        _draw_sector_ring(local_center, inner_radius, outer_radius, start_angle, end_angle, ring_color)
```

#### 2. ç½‘æ ¼æ¸²æŸ“æ¨¡å¼

**æ ¸å¿ƒæ€æƒ³**ï¼šä½¿ç”¨ä¼ ç»Ÿçš„2Dç½‘æ ¼é‡‡æ ·ï¼Œç„¶åå°†è¿é€šçš„å¯ç§»åŠ¨åŒºåŸŸåˆå¹¶ç»˜åˆ¶ã€‚

```gdscript
func _draw_grid_move_range(local_center: Vector2, current_char_height: float) -> void:
    var grid_size = grid_detection_size
    var check_radius = max_range
    
    # åˆ›å»º2Dç½‘æ ¼å­˜å‚¨æ£€æµ‹ç»“æœ
    var grid_width = int((check_radius * 2) / grid_size) + 1
    var grid_height = int((check_radius * 2) / grid_size) + 1
    var movability_grid = []
    
    # ç½‘æ ¼é‡‡æ ·
    for i in range(grid_width):
        for j in range(grid_height):
            var world_pos = center_position + Vector2(x, y)
            var is_movable = _check_position_movability_optimized(...)
            movability_grid[i][j] = is_movable
    
    # ç»˜åˆ¶è¿ç»­åŒºåŸŸ
    _draw_movability_regions(movability_grid, local_center, grid_size, check_radius)
```

### å¾„å‘ç¯å¸¦é‡‡æ ·ç®—æ³•

è¿™æ˜¯æ‰‡å½¢æ¸²æŸ“çš„æ ¸å¿ƒç®—æ³•ï¼Œç”¨äºç²¾ç¡®è®¡ç®—æ¯ä¸ªç¯å¸¦çš„å¯ç§»åŠ¨æ€§ï¼š

```gdscript
func _sample_radial_ring_movability(local_center: Vector2, start_angle: float, end_angle: float,
                                   inner_radius: float, outer_radius: float, ...) -> float:
    var total_samples = 0
    var movable_samples = 0
    
    # é‡‡æ ·å‚æ•°ï¼ˆæ€§èƒ½vsç²¾åº¦å¹³è¡¡ï¼‰
    var angle_step = performance_mode ? 2.5 : 1.5  # è§’åº¦æ­¥é•¿
    var radius_step = performance_mode ? 6.0 : 4.0  # åŠå¾„æ­¥é•¿
    
    # åœ¨å¾„å‘ç¯å¸¦å†…é‡‡æ ·
    var radius = inner_radius + radius_step
    while radius <= outer_radius:
        var angle = start_angle
        while angle <= end_angle:
            var rad = deg_to_rad(angle)
            var offset = Vector2(cos(rad), sin(rad)) * radius
            var world_pos = center_position + offset
            
            total_samples += 1
            if _check_position_movability_optimized(world_pos, ...):
                movable_samples += 1
            
            angle += angle_step
        radius += radius_step
    
    return float(movable_samples) / float(max(total_samples, 1))
```

### é¢œè‰²è®¡ç®—ç®—æ³•

ç³»ç»Ÿä½¿ç”¨æ™ºèƒ½é¢œè‰²æ˜ å°„ï¼Œæ ¹æ®å¯ç§»åŠ¨æ€§æ¯”ä¾‹å’Œè·ç¦»æ¯”ä¾‹åŠ¨æ€è°ƒæ•´ï¼š

```gdscript
func _get_smooth_sector_color(movability_ratio: float, distance_ratio: float) -> Color:
    var is_edge_area = distance_ratio > 0.9  # è¾¹ç¼˜åŒºåŸŸæ›´ä¸¥æ ¼
    var base_color: Color
    
    if is_edge_area:
        # è¾¹ç¼˜åŒºåŸŸï¼šæ›´ä¸¥æ ¼çš„é˜ˆå€¼
        if movability_ratio >= 0.8:     # éœ€è¦80%ä»¥ä¸Šæ‰æ˜¾ç¤ºç»¿è‰²
            base_color = movable_area_color
        elif movability_ratio >= 0.6:   # 60%ä»¥ä¸Šæ˜¾ç¤ºé»„è‰²
            var t = (movability_ratio - 0.6) / 0.2
            base_color = partial_movable_color.lerp(movable_area_color, t)
        elif movability_ratio >= 0.4:   # 40%ä»¥ä¸Šæ˜¾ç¤ºæ©™è‰²
            var t = (movability_ratio - 0.4) / 0.2
            base_color = barely_movable_color.lerp(partial_movable_color, t)
        else:
            base_color = unmovable_area_color
    else:
        # å†…éƒ¨åŒºåŸŸï¼šä¿æŒå®½æ¾é˜ˆå€¼
        # ... ç±»ä¼¼é€»è¾‘ä½†é˜ˆå€¼æ›´å®½æ¾
    
    # è·ç¦»åç§»æ•ˆæœï¼ˆå¯é€‰ï¼‰
    if not disable_distance_offset:
        var distance_influence = (1.0 - movability_ratio) * 0.5
        if distance_ratio > 0.85:
            var red_shift = (distance_ratio - 0.85) / 0.15 * distance_influence * 0.08
            base_color = base_color.lerp(unmovable_area_color, red_shift)
    
    return base_color
```

### ç¯å½¢æ‰‡å½¢ç»˜åˆ¶

```gdscript
func _draw_sector_ring(center: Vector2, inner_radius: float, outer_radius: float, 
                      start_angle: float, end_angle: float, color: Color) -> void:
    var points = PackedVector2Array()
    var angle_step = 2.0  # æ¯2åº¦ä¸€ä¸ªç‚¹
    
    # æ·»åŠ å¤–å¼§çš„ç‚¹
    var angle = start_angle
    while angle <= end_angle:
        var rad = deg_to_rad(angle)
        var point = center + Vector2(cos(rad), sin(rad)) * outer_radius
        points.append(point)
        angle += angle_step
    
    # æ·»åŠ å†…å¼§çš„ç‚¹ï¼ˆé€†åºï¼‰
    angle = end_angle
    while angle >= start_angle:
        var rad = deg_to_rad(angle)
        var point = center + Vector2(cos(rad), sin(rad)) * inner_radius
        points.append(point)
        angle -= angle_step
    
    # ç»˜åˆ¶å¡«å……çš„ç¯å½¢æ‰‡å½¢
    if points.size() >= 3:
        draw_colored_polygon(points, color)
        
        # å¯é€‰ï¼šæ¸å˜è¾¹ç¼˜æ•ˆæœ
        if use_gradient_effect and smooth_color_transition:
            var soft_color = Color(color.r, color.g, color.b, color.a * 0.6)
            # ç»˜åˆ¶æŸ”åŒ–è¾¹ç¼˜...
```

---

## ç¢°æ’æ£€æµ‹ç³»ç»Ÿ

### åŠ¨æ€ç¢°æ’å½¢çŠ¶å¤åˆ¶

ç³»ç»Ÿä½¿ç”¨åŠ¨æ€Area2Dè¿›è¡Œç¢°æ’æ£€æµ‹ï¼Œè‡ªåŠ¨å¤åˆ¶è§’è‰²çš„ç¢°æ’å½¢çŠ¶ï¼š

```gdscript
func update_test_area_shape(char_node: Node2D) -> void:
    var char_area = char_node.get_node_or_null("CharacterArea")
    var char_collision_shape = # æŸ¥æ‰¾è§’è‰²çš„ç¢°æ’å½¢çŠ¶
    
    # å¤åˆ¶åˆ°æµ‹è¯•åŒºåŸŸ
    var test_collision_shape = test_area.get_node_or_null("TestCollisionShape")
    test_collision_shape.shape = char_collision_shape.shape.duplicate()
```

### å¼‚æ­¥ç¢°æ’æ£€æµ‹

```gdscript
func _check_target_collision(target_pos: Vector2) -> void:
    test_area.global_position = target_pos
    
    # ç­‰å¾…ä¸€å¸§ç¡®ä¿ç¢°æ’æ£€æµ‹æ›´æ–°
    await get_tree().process_frame
    
    var overlapping_areas = test_area.get_overlapping_areas()
    is_position_occupied = false
    
    for area in overlapping_areas:
        var area_parent = area.get_parent()
        
        # é€šè¿‡IDæ¯”è¾ƒè·³è¿‡è‡ªå·±
        if character and area_parent.is_in_group("party_members"):
            var other_char = # è·å–å…¶ä»–è§’è‰²æ•°æ®
            if other_char and character.id == other_char.id:
                continue  # è·³è¿‡è‡ªå·±
            
            is_position_occupied = true
            break
    
    queue_redraw()  # æ›´æ–°æ˜¾ç¤º
```

---

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### å¤šå±‚æ¬¡é‡‡æ ·ä¼˜åŒ–

```gdscript
# æ€§èƒ½æ¨¡å¼å‚æ•°è°ƒæ•´
var angle_step = performance_mode ? 2.5 : 1.5    # è§’åº¦é‡‡æ ·ç²¾åº¦
var radius_step = performance_mode ? 6.0 : 4.0   # åŠå¾„é‡‡æ ·ç²¾åº¦
var radial_divisions = performance_mode ? 8 : 10  # å¾„å‘åˆ†å‰²æ•°é‡
```

### æ—©æœŸé€€å‡ºä¼˜åŒ–

```gdscript
func _check_position_movability_optimized(...) -> bool:
    # 1. æœ€å¿«çš„æ£€æŸ¥ï¼šæ°´å¹³è·ç¦»
    var horizontal_distance = abs(world_pos.x - char_ground_pos.x)
    if horizontal_distance > max_range:
        return false  # ç«‹å³é€€å‡º
    
    # 2. åœ°é¢æ£€æŸ¥
    var y_offset = world_pos.y - base_ground_y
    if y_offset > 0:
        return false  # ç«‹å³é€€å‡º
    
    # 3. æ›´å¤æ‚çš„3Dè·ç¦»è®¡ç®—...
```

### ç¼“å­˜å’Œé¢„è®¡ç®—

```gdscript
# é¢„è®¡ç®—å¸¸ç”¨å€¼
var max_height_level = max_range / grid_step
var char_ground_pos_cached = char_ground_pos

# ç¼“å­˜ç¢°æ’æ£€æµ‹ç»“æœ
var collision_cache = {}
```

### åŒºåŸŸè£å‰ª

```gdscript
# åªæ£€æµ‹åœ†å½¢èŒƒå›´å†…çš„åŒºåŸŸ
var distance_to_center = Vector2(x, y).length()
if distance_to_center > max_range:
    continue  # è·³è¿‡è¶…å‡ºèŒƒå›´çš„åŒºåŸŸ
```

---

## è°ƒè¯•ç³»ç»Ÿ

### è±¡é™è°ƒè¯•

æŒ‰é”®1-4å¯ä»¥å•ç‹¬æ˜¾ç¤ºç‰¹å®šè±¡é™ï¼Œä¾¿äºè°ƒè¯•ä¸å¯¹ç§°é—®é¢˜ï¼š

```gdscript
func _draw_debug_quadrant(center: Vector2, quadrant: int) -> void:
    var start_angle, end_angle: float
    match quadrant:
        1: start_angle = 0.0; end_angle = 90.0      # å³ä¸‹
        2: start_angle = 90.0; end_angle = 180.0    # å·¦ä¸‹
        3: start_angle = 180.0; end_angle = 270.0   # å·¦ä¸Š
        4: start_angle = 270.0; end_angle = 360.0   # å³ä¸Š
    
    _draw_filled_sector(center, max_range, start_angle, end_angle, Color.CYAN)
```

### é¼ æ ‡ç‚¹å‡»è°ƒè¯•

æŒ‰Ié”®å¯ç”¨é¼ æ ‡è°ƒè¯•æ¨¡å¼ï¼Œç‚¹å‡»ä»»æ„ä½ç½®æ˜¾ç¤ºè¯¦ç»†çš„é‡‡æ ·ä¿¡æ¯ï¼š

```gdscript
func _debug_mouse_position(mouse_pos: Vector2) -> void:
    # è®¡ç®—è§’åº¦ã€è·ç¦»ã€æ‰€å±æ‰‡å½¢
    var offset = mouse_pos - center_position
    var angle_deg = rad_to_deg(atan2(offset.y, offset.x))
    var sector_index = int(angle_deg / (360.0 / sector_count))
    
    # æ˜¾ç¤ºè¯¦ç»†é‡‡æ ·ä¿¡æ¯
    print("æ‰‡å½¢ç´¢å¼•: %d, å¯ç§»åŠ¨æ€§: %.2f%%" % [sector_index, movability * 100])
```

### æ€§èƒ½ç›‘æ§

```gdscript
# å®æ—¶æ˜¾ç¤ºé‡‡æ ·ä¿¡æ¯
var debug_text = "é‡‡æ ·å‚æ•°: è§’åº¦æ­¥é•¿%.1fÂ°, åŠå¾„æ­¥é•¿%.1fpx" % [angle_step, radius_step]
draw_string(font, debug_pos, debug_text, ...)
```

---

## é…ç½®å‚æ•°è¯´æ˜

### æ ¸å¿ƒæ¸²æŸ“å‚æ•°| å‚æ•° | é»˜è®¤å€¼ | è¯´æ˜ ||------|--------|------|| `sector_rendering` | true | å¯ç”¨æ‰‡å½¢æ¸²æŸ“æ¨¡å¼ï¼ˆæ¨èï¼‰ || `sector_count` | 36 | æ‰‡å½¢æ•°é‡ï¼Œå½±å“ç²¾åº¦å’Œæ€§èƒ½ || `radial_divisions` | 10 | å¾„å‘åˆ†å‰²æ•°ï¼Œæ§åˆ¶è·ç¦»å±‚æ¬¡ç²¾ç»†åº¦ || `continuous_rendering` | true | è¿ç»­ç»˜åˆ¶æ¨¡å¼ï¼Œæ¶ˆé™¤ç©ºéš™ || `smooth_rendering` | true | å¹³æ»‘åœ†æ¶¦ç»˜åˆ¶ |### ğŸ¨ é¢œè‰²ç³»ç»Ÿå‚æ•°ï¼ˆæ–°å¢ï¼‰| å‚æ•° | é»˜è®¤å€¼ | è¯´æ˜ ||------|--------|------|| `simple_color_mode` | true | **ç®€å•é¢œè‰²æ¨¡å¼ï¼šåªæœ‰ç»¿è‰²å’Œçº¢è‰²** || `movability_threshold` | 0.5 | å¯ç§»åŠ¨æ€§é˜ˆå€¼ï¼ˆ50%ä»¥ä¸Šæ˜¾ç¤ºç»¿è‰²ï¼‰ || `movable_area_color` | ç»¿è‰² | å¯ç§»åŠ¨åŒºåŸŸé¢œè‰² || `unmovable_area_color` | çº¢è‰² | ä¸å¯ç§»åŠ¨åŒºåŸŸé¢œè‰² |

### æ€§èƒ½ä¼˜åŒ–å‚æ•°

| å‚æ•° | é»˜è®¤å€¼ | è¯´æ˜ |
|------|--------|------|
| `performance_mode` | false | æ€§èƒ½æ¨¡å¼ï¼šé™ä½ç²¾åº¦æé«˜é€Ÿåº¦ |
| `grid_detection_size` | 16 | ç½‘æ ¼æ£€æµ‹å¤§å°ï¼ˆåƒç´ ï¼‰ |
| `smooth_color_transition` | true | å¹³æ»‘é¢œè‰²è¿‡æ¸¡ |

### è°ƒè¯•å‚æ•°

| å‚æ•° | é»˜è®¤å€¼ | è¯´æ˜ |
|------|--------|------|
| `disable_distance_offset` | false | ç¦ç”¨è·ç¦»åç§»æ•ˆæœ |
| `show_unmovable_areas` | true | æ˜¾ç¤ºä¸å¯ç§»åŠ¨åŒºåŸŸ |
| `use_gradient_effect` | true | ä½¿ç”¨æ¸å˜æ•ˆæœ |

### æ¨èé…ç½®

**ğŸ¨ ç®€å•é¢œè‰²æ¨¡å¼**ï¼ˆæ¨èï¼‰ï¼š```gdscriptsimple_color_mode = true        # ç®€å•äºŒå…ƒé¢œè‰²movability_threshold = 0.5      # 50%é˜ˆå€¼sector_rendering = truesector_count = 36```**é«˜è´¨é‡å¤æ‚æ¨¡å¼**ï¼š```gdscriptsimple_color_mode = false       # å¤šçº§é¢œè‰²æ˜¾ç¤ºsector_rendering = truesector_count = 36radial_divisions = 10performance_mode = false```**æ€§èƒ½æ¨¡å¼**ï¼š```gdscriptsimple_color_mode = true        # ç®€å•é¢œè‰²æé«˜æ€§èƒ½sector_rendering = truesector_count = 24               # å‡å°‘æ‰‡å½¢æ•°é‡radial_divisions = 8            # å‡å°‘å¾„å‘åˆ†å‰²performance_mode = true         # å¯ç”¨æ€§èƒ½æ¨¡å¼```**è°ƒè¯•æ¨¡å¼**ï¼š```gdscriptsimple_color_mode = false       # ä½¿ç”¨å¤æ‚é¢œè‰²ä¾¿äºè°ƒè¯•disable_distance_offset = true  # çº¯å¯ç§»åŠ¨æ€§æ˜¾ç¤ºshow_unmovable_areas = true     # æ˜¾ç¤ºé—®é¢˜åŒºåŸŸ```

---

## ç®—æ³•å¤æ‚åº¦åˆ†æ

### æ‰‡å½¢æ¸²æŸ“æ¨¡å¼

**æ—¶é—´å¤æ‚åº¦**ï¼šO(S Ã— R Ã— A Ã— D)
- S: sector_count (æ‰‡å½¢æ•°é‡)
- R: radial_divisions (å¾„å‘åˆ†å‰²æ•°)
- A: è§’åº¦é‡‡æ ·ç‚¹æ•° â‰ˆ (sector_angle / angle_step)
- D: å¾„å‘é‡‡æ ·ç‚¹æ•° â‰ˆ (ring_width / radius_step)

**ç©ºé—´å¤æ‚åº¦**ï¼šO(1) - åªä½¿ç”¨ä¸´æ—¶å˜é‡

### ç½‘æ ¼æ¸²æŸ“æ¨¡å¼

**æ—¶é—´å¤æ‚åº¦**ï¼šO(W Ã— H + C)
- W: ç½‘æ ¼å®½åº¦ â‰ˆ (2 Ã— max_range / grid_size)
- H: ç½‘æ ¼é«˜åº¦ â‰ˆ (2 Ã— max_range / grid_size)
- C: è¿é€šåŒºåŸŸæŸ¥æ‰¾å¤æ‚åº¦

**ç©ºé—´å¤æ‚åº¦**ï¼šO(W Ã— H) - éœ€è¦å­˜å‚¨æ•´ä¸ªç½‘æ ¼

### æ€§èƒ½å¯¹æ¯”

åœ¨ç›¸åŒç²¾åº¦ä¸‹ï¼Œæ‰‡å½¢æ¸²æŸ“é€šå¸¸æ¯”ç½‘æ ¼æ¸²æŸ“æ›´é«˜æ•ˆï¼Œå› ä¸ºï¼š
1. åªè®¡ç®—åœ†å½¢èŒƒå›´å†…çš„åŒºåŸŸ
2. å¾„å‘é‡‡æ ·å¯†åº¦å¯æ ¹æ®è·ç¦»åŠ¨æ€è°ƒæ•´
3. æ— éœ€å­˜å‚¨å¤§é‡ç½‘æ ¼æ•°æ®

---

## æ€»ç»“

è¯¥ç§»åŠ¨ç³»ç»Ÿç®—æ³•çš„æ ¸å¿ƒä¼˜åŠ¿ï¼š

1. **ç²¾ç¡®æ€§**ï¼šæ‰‡å½¢+å¾„å‘ç¯å¸¦çš„åŒé‡åˆ†å‰²ç¡®ä¿ä½ç½®çº§ç²¾åº¦
2. **æ€§èƒ½**ï¼šå¤šå±‚æ¬¡ä¼˜åŒ–ç­–ç•¥ï¼Œæ”¯æŒå®æ—¶æ¸²æŸ“
3. **å¯é…ç½®æ€§**ï¼šä¸°å¯Œçš„å‚æ•°é…ç½®ï¼Œé€‚åº”ä¸åŒéœ€æ±‚
4. **å¯è°ƒè¯•æ€§**ï¼šå®Œå–„çš„è°ƒè¯•ç³»ç»Ÿï¼Œä¾¿äºé—®é¢˜å®šä½
5. **æ‰©å±•æ€§**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼Œæ˜“äºæ·»åŠ æ–°åŠŸèƒ½

è¯¥ç³»ç»Ÿèƒ½å¤Ÿåœ¨ä¿è¯è§†è§‰æ•ˆæœçš„åŒæ—¶ï¼Œæä¾›å‡ºè‰²çš„æ€§èƒ½è¡¨ç°ï¼Œæ˜¯ä¸€ä¸ªæˆç†Ÿçš„æ¸¸æˆç§»åŠ¨ç³»ç»Ÿè§£å†³æ–¹æ¡ˆã€‚ 